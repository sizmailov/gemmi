

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Structure analysis &mdash; Gemmi 0.3.7 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Grids and maps" href="grid.html" />
    <link rel="prev" title="Molecular models" href="mol.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Gemmi
          

          
          </a>

          
            
            
              <div class="version">
                0.3.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cif.html">CIF Parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="symmetry.html">Symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="mol.html">Molecular models</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Structure analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#neighbor-search">Neighbor search</a></li>
<li class="toctree-l2"><a class="reference internal" href="#contact-search">Contact search</a></li>
<li class="toctree-l2"><a class="reference internal" href="#selections">Selections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#graph-analysis">Graph analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graph-isomorphism">Graph isomorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#substructure-matching">Substructure matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maximum-common-subgraph">Maximum common subgraph</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#torsion-angles">Torsion Angles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#local-copy-of-the-pdb-archive">Local copy of the PDB archive</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="grid.html">Grids and maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="hkl.html">Reciprocal space</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Gemmi program</a></li>
<li class="toctree-l1"><a class="reference external" href="https://project-gemmi.github.io/gemmi/api/python">Python API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Gemmi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Structure analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/analysis.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="structure-analysis">
<h1>Structure analysis<a class="headerlink" href="#structure-analysis" title="Permalink to this headline">¶</a></h1>
<div class="section" id="neighbor-search">
<h2>Neighbor search<a class="headerlink" href="#neighbor-search" title="Permalink to this headline">¶</a></h2>
<p>Fixed-radius near neighbor search is usually implemented using
the <a class="reference external" href="https://en.wikipedia.org/wiki/Cell_lists">cell lists</a> method,
also known as binning, bucketing or cell technique
(or cubing – as it was called in an <a class="reference external" href="https://web.stanford.edu/class/sbio228/public/readings/Molecular_Simulation_I_Lecture4/Levinthal_SCIAM_66_Protein_folding.pdf">article</a> from 1966).
The method is simple. The unit cell (or the area where the molecules are
located) is divided into small cells. The size of these cells depends
on the search radius. Each cell stores the list of atoms in its area;
these lists are used for fast lookup of atoms.</p>
<p>In Gemmi the cell technique is implemented in a class named <code class="docutils literal notranslate"><span class="pre">SubCells</span></code>
(“sub-” because these cells are subdivision of the unit cell).
The implementation works with both crystal and non-crystal system and:</p>
<ul class="simple">
<li><p>handles crystallographic symmetry (including non-standard settings with
origin shift that are present in a couple hundreds of PDB entries),</p></li>
<li><p>handles strict NCS (MTRIX record in the PDB format that is not “given”;
in mmCIF it is the _struct_ncs_oper category),</p></li>
<li><p>handles alternative locations (atoms from different conformers are not
neighbors),</p></li>
<li><p>can find neighbors any number of unit cells apart; surprisingly,
molecules from different and not neighboring unit cells can be
in contact, either because of the molecule shape (a single chain can be
<a class="reference internal" href="mol.html#long-chain"><span class="std std-ref">longer then four unit cells</span></a>) or because of
the non-optimal choice of symmetric images in the model
(some PDB entries have even links between chains more than
10 unit cells away which cannot be expressed in the 1555 type of notation).</p></li>
</ul>
<p>Note that while an atom can be bonded with its own symmetric image,
it sometimes happens that an atom meant to be on a special position
is slightly off, and its symmetric images represent the same atom
(so we may have four nearby images each with occupancy 0.25).
Such images will be returned by the SubCells class as neighbors
and need to be filtered out by the users.</p>
<p>The constructor of SubCells divides the unit cell into bins.
For this it needs to know the the maximum radius that will be used in searches,
as well as the unit cell. Since the system may be non-periodic,
the constructor also takes the model as an argument – it is used to
calculate the bounding box for the model if there is no unit cell.
It is also stored and used if <code class="docutils literal notranslate"><span class="pre">populate()</span></code> is called.
The C++ signature (in <code class="docutils literal notranslate"><span class="pre">gemmi/subcells.hpp</span></code>) is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SubCells</span><span class="o">::</span><span class="n">SubCells</span><span class="p">(</span><span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">,</span> <span class="k">const</span> <span class="n">UnitCell</span><span class="o">&amp;</span> <span class="n">cell</span><span class="p">,</span> <span class="kt">double</span> <span class="n">max_radius</span><span class="p">)</span>
</pre></div>
</div>
<p>Then the cell lists need to be populated with items either by calling:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">SubCells</span><span class="o">::</span><span class="n">populate</span><span class="p">(</span><span class="kt">bool</span> <span class="n">include_h</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span>
</pre></div>
</div>
<p>or by adding individual atoms:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">SubCells</span><span class="o">::</span><span class="n">add_atom</span><span class="p">(</span><span class="k">const</span> <span class="n">Atom</span><span class="o">&amp;</span> <span class="n">atom</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_ch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_atom</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">n_ch</span></code> is the index of the chain in the model, <code class="docutils literal notranslate"><span class="pre">n_res</span></code> is the index
of the residue in the chain, and <code class="docutils literal notranslate"><span class="pre">n_atom</span></code> is the index of the atom
in the residue.</p>
<p>An example in Python:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gemmi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1pfe.cif.gz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subcells</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">SubCells</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subcells</span><span class="o">.</span><span class="n">populate</span><span class="p">()</span>
</pre></div>
</div>
<p>If we’d like to choose which atoms to add, for example to ignore hydrogens,
we could use <code class="docutils literal notranslate"><span class="pre">add_atom()</span></code> instead:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subcells</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">SubCells</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n_ch</span><span class="p">,</span> <span class="n">chain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">n_res</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chain</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">n_atom</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_hydrogen</span><span class="p">():</span>
<span class="gp">... </span>                <span class="n">subcells</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">n_ch</span><span class="p">,</span> <span class="n">n_res</span><span class="p">,</span> <span class="n">n_atom</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>The following functions search for atoms near the specified atom or point:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mark</span><span class="o">*&gt;</span> <span class="n">SubCells</span><span class="o">::</span><span class="n">find_neighbors</span><span class="p">(</span><span class="k">const</span> <span class="n">Atom</span><span class="o">&amp;</span> <span class="n">atom</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min_dist</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">)</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mark</span><span class="o">*&gt;</span> <span class="n">SubCells</span><span class="o">::</span><span class="n">find_atoms</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="n">altloc</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_atom</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sole_residue</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">SeqId</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">sole_atom</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">marks</span> <span class="o">=</span> <span class="n">subcells</span><span class="o">.</span><span class="n">find_neighbors</span><span class="p">(</span><span class="n">ref_atom</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Position</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">marks</span> <span class="o">=</span> <span class="n">subcells</span><span class="o">.</span><span class="n">find_atoms</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">marks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&lt;gemmi.SubCells.Mark O of atom 0/7/3&gt;</span>
</pre></div>
</div>
<p>Non-negative <code class="docutils literal notranslate"><span class="pre">min_dist</span></code> in the <code class="docutils literal notranslate"><span class="pre">find_neighbors()</span></code> call prevents
the atom whose neighbors we search from being included in the results
(the distance of the atom to itself is zero).</p>
<p>Additionally, in C++ you may use a function that takes a callback
as the last argument (usage examples are in the source code):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">SubCells</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="n">altloc</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">)</span>
</pre></div>
</div>
<p>Cell-lists store <code class="docutils literal notranslate"><span class="pre">Mark</span></code>s. When searching for neighbors you get references
(in C++ – pointers) to these marks.
<code class="docutils literal notranslate"><span class="pre">Mark</span></code> has a number of properties: <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code>,
<code class="docutils literal notranslate"><span class="pre">altloc</span></code>, <code class="docutils literal notranslate"><span class="pre">element</span></code>, <code class="docutils literal notranslate"><span class="pre">image_idx</span></code> (index of the symmetry operation
that was used to generate this mark, 0 for identity),
<code class="docutils literal notranslate"><span class="pre">chain_idx</span></code>, <code class="docutils literal notranslate"><span class="pre">residue_idx</span></code> and <code class="docutils literal notranslate"><span class="pre">atom_idx</span></code>.</p>
<p>The references to the original model and to atoms are not stored.
<code class="docutils literal notranslate"><span class="pre">Mark</span></code> has a method <code class="docutils literal notranslate"><span class="pre">to_cra()</span></code> that needs to be called with <code class="docutils literal notranslate"><span class="pre">Model</span></code>
as an argument to get a triple of Chain, Residue and Atom:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">CRA</span> <span class="n">SubCells</span><span class="o">::</span><span class="n">Mark</span><span class="o">::</span><span class="n">to_cra</span><span class="p">(</span><span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cra</span> <span class="o">=</span> <span class="n">marks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_cra</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cra</span><span class="o">.</span><span class="n">chain</span>
<span class="go">&lt;gemmi.Chain A with 79 res&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cra</span><span class="o">.</span><span class="n">residue</span>
<span class="go">&lt;gemmi.Residue 8(DC) with 19 atoms&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cra</span><span class="o">.</span><span class="n">atom</span>
<span class="go">&lt;gemmi.Atom O5&#39; at (-0.0, 13.9, -17.6)&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Mark</span></code> also has a little helper method <code class="docutils literal notranslate"><span class="pre">pos()</span></code> that returns
<code class="docutils literal notranslate"><span class="pre">Position(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Position</span> <span class="n">SubCells</span><span class="o">::</span><span class="n">Mark</span><span class="o">::</span><span class="n">pos</span><span class="p">()</span> <span class="k">const</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">marks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span><span class="p">()</span>
<span class="go">&lt;gemmi.Position(19.659, 20.2489, 17.645)&gt;</span>
</pre></div>
</div>
<p>Note that it can be the position of a symmetric image of the atom.
In this example the “original” atom is in a different location:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cra</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">pos</span>
<span class="go">&lt;gemmi.Position(-0.028, 13.85, -17.645)&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="contact-search">
<h2>Contact search<a class="headerlink" href="#contact-search" title="Permalink to this headline">¶</a></h2>
<p>Contacts in a molecule or in a crystal can be found using the neighbor search
described in the previous section. But to make it easier we have a dedicated
class ContactSearch. It uses the neighbor search to find pairs of atoms
close to each other and applies the filters described below.</p>
<p>When constructing ContactSearch we set the overall maximum search distance.
This distance is stored as the <code class="docutils literal notranslate"><span class="pre">search_radius</span></code> property:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">ContactSearch</span><span class="p">(</span><span class="mf">4.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span><span class="o">.</span><span class="n">search_radius</span>
<span class="go">4.0</span>
</pre></div>
</div>
<p>Additionally, we can set up per-element radii.
This excludes pairs of atoms in a distance larger than the sum
of their per-element radii.
The radii are initialized as a linear function of the
<a class="reference internal" href="mol.html#covalent-radius"><span class="std std-ref">covalent radius</span></a>:
<em>r</em> = <em>a</em> × <em>r</em><sub>cov</sub> + <em>b</em>/2.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span><span class="o">.</span><span class="n">setup_atomic_radii</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Then each radius can be accessed and modified individually:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span><span class="o">.</span><span class="n">get_radius</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;Zr&#39;</span><span class="p">))</span>
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span><span class="o">.</span><span class="n">set_radius</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;Hg&#39;</span><span class="p">),</span> <span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we have the <code class="docutils literal notranslate"><span class="pre">ignore</span></code> property that can take
one of the following values:</p>
<ul class="simple">
<li><p>ContactSearch.Ignore.Nothing – no filtering here,</p></li>
<li><p>ContactSearch.Ignore.SameResidue – ignore atom pairs from the same residue,</p></li>
<li><p>ContactSearch.Ignore.AdjacentResidues – ignore atom pairs from the same or
adjacent residues,</p></li>
<li><p>ContactSearch.Ignore.SameChain – show only inter-chain contacts
(including contacts between different symmetry images of one chain),</p></li>
<li><p>ContactSearch.Ignore.SameAsu – show only contacts between different
asymmetric units.</p></li>
</ul>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span><span class="o">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">ContactSearch</span><span class="o">.</span><span class="n">Ignore</span><span class="o">.</span><span class="n">AdjacentResidues</span>
</pre></div>
</div>
<p>You can also ignore atoms that have occupancy below the specified
threshold:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span><span class="o">.</span><span class="n">min_occupancy</span> <span class="o">=</span> <span class="mf">0.01</span>
</pre></div>
</div>
<p>Sometimes, it is handy to get each atom pair twice (as A-B and B-A).
In such case make the <code class="docutils literal notranslate"><span class="pre">twice</span></code> property true. By default, it is false:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span><span class="o">.</span><span class="n">twice</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Next property deals with atoms at special positions (such as rotation axis).
Such atoms can be slightly off the special position (because macromolecular
refinement programs usually don’t constrain coordinates), so we must ensure
that an atom that should sit on the special position and its apparent symmetry
image are not regarded a contact. We assume that if the distance between
an atom and its image is small, it is not a real thing.
For larger distances we assume it is a real contact with atom’s symmetry mate.
To tell apart the two cases we use a cut-off distance that can be modified:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span><span class="o">.</span><span class="n">special_pos_cutoff_sq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1"># setting cut-off to 0.5A</span>
</pre></div>
</div>
<p>The contact search uses an instance of SubCells.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/5cvz_final.pdb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">setup_entities</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subcells</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">SubCells</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subcells</span><span class="o">.</span><span class="n">populate</span><span class="p">()</span>
</pre></div>
</div>
<p>If you’d like to ignore hydrogens from the model,
call <code class="docutils literal notranslate"><span class="pre">subcells.populate(include_h=False)</span></code>.</p>
<p>If you’d like to ignore waters, either remove waters from the Model
(function <code class="docutils literal notranslate"><span class="pre">remove_waters()</span></code>) or ignore results that contain waters.</p>
<p>The actual contact search is done by:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">find_contacts</span><span class="p">(</span><span class="n">subcells</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="go">49</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
<span class="go">&lt;gemmi.ContactSearch.Result object at 0x...&gt;</span>
</pre></div>
</div>
<p>The ContactSearch.Result class has four properties:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">partner1</span>
<span class="go">&lt;gemmi.CRA A/SER 21/OG&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">partner2</span>
<span class="go">&lt;gemmi.CRA A/TYR 24/N&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image_idx</span>
<span class="go">52</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dist</span>
<span class="go">2.8613362312316895</span>
</pre></div>
</div>
<p>The first two properties are <a class="reference internal" href="mol.html#cra"><span class="std std-ref">CRA</span></a>s for the involved atoms.
The <code class="docutils literal notranslate"><span class="pre">image_idx</span></code> is an index of the symmetry image (both crystallographic
symmetry and strict NCS count).
Value 0 would mean that both atoms (<code class="docutils literal notranslate"><span class="pre">partner1</span></code> and <code class="docutils literal notranslate"><span class="pre">partner2</span></code>)
are in the same unit.
In this example the value can be high because it is a structure of
icosahedral viral capsid with 240 identical units in the unit cell.
The last property is the distance between atoms.</p>
<p>See also command-line program <a class="reference internal" href="utils.html#gemmi-contact"><span class="std std-ref">gemmi-contact</span></a>.</p>
<p>Gemmi provides also an undocumented class LinkHunt which matches
contacts to links definitions from <a class="reference internal" href="mol.html#ccd-etc"><span class="std std-ref">monomer library</span></a>
and to connections (LINK, SSBOND) from the structure.
If you would find it useful, contact the author.</p>
</div>
<div class="section" id="selections">
<span id="id1"></span><h2>Selections<a class="headerlink" href="#selections" title="Permalink to this headline">¶</a></h2>
<p>For now, Gemmi supports only the selection syntax from MMDB,
called CID (Coordinate ID). The syntax is described at the bottom
of the <a class="reference external" href="http://www.ccp4.ac.uk/html/pdbcur.html">pdbcur documentation</a>.</p>
<p>The selections in Gemmi are not widely used yet and the API may evolve.
The example below demonstrates currently provided functions:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1pfe.cif.gz&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># select all Cl atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sel</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">parse_cid</span><span class="p">(</span><span class="s1">&#39;[CL]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># get the first result as pointer to model and CRA (chain, residue, atom)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sel</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
<span class="go">(&lt;gemmi.Model 1 with 2 chain(s)&gt;, &lt;gemmi.CRA A/CL 20/CL&gt;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sel</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">parse_cid</span><span class="p">(</span><span class="s1">&#39;A/1-4/N9&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sel</span><span class="o">.</span><span class="n">to_cid</span><span class="p">()</span>
<span class="go">&#39;//A/1.-4./N9&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iterate over hierarchy filtered by the selection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">sel</span><span class="o">.</span><span class="n">models</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">sel</span><span class="o">.</span><span class="n">chains</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">chain</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">sel</span><span class="o">.</span><span class="n">residues</span><span class="p">(</span><span class="n">chain</span><span class="p">):</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   -&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">residue</span><span class="p">))</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">sel</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
<span class="gp">... </span>                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;          -&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">- A</span>
<span class="go">   - 1(DG)</span>
<span class="go">          - N9</span>
<span class="go">   - 2(DC)</span>
<span class="go">   - 3(DG)</span>
<span class="go">          - N9</span>
<span class="go">   - 4(DT)</span>
</pre></div>
</div>
</div>
<div class="section" id="graph-analysis">
<span id="id2"></span><h2>Graph analysis<a class="headerlink" href="#graph-analysis" title="Permalink to this headline">¶</a></h2>
<p>The graph algorithms in Gemmi are limited to finding the shortest path
between atoms (bonds = graph edges). This part of the library is not
documented yet.</p>
<p>The rest of this section shows how to use Gemmi together with external
graph analysis libraries to analyse the similarity of chemical molecules.
To do this, first we set up a graph corresponding to the molecule.</p>
<p>Here we show how it can be done in the Boost Graph Library.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/graph/graph_traits.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/graph/adjacency_list.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/cif.hpp&gt;             // for cif::read_file</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/chemcomp.hpp&gt;        // for ChemComp, make_chemcomp_from_block</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">AtomVertex</span> <span class="p">{</span>
  <span class="n">gemmi</span><span class="o">::</span><span class="n">Element</span> <span class="n">el</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">El</span><span class="o">::</span><span class="n">X</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">BondEdge</span> <span class="p">{</span>
  <span class="n">gemmi</span><span class="o">::</span><span class="n">BondType</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">Graph</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">adjacency_list</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">vecS</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">vecS</span><span class="p">,</span>
                                    <span class="n">boost</span><span class="o">::</span><span class="n">undirectedS</span><span class="p">,</span>
                                    <span class="n">AtomVertex</span><span class="p">,</span> <span class="n">BondEdge</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">Graph</span> <span class="nf">make_graph</span><span class="p">(</span><span class="k">const</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">ChemComp</span><span class="o">&amp;</span> <span class="n">cc</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Graph</span> <span class="n">g</span><span class="p">(</span><span class="n">cc</span><span class="p">.</span><span class="n">atoms</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">cc</span><span class="p">.</span><span class="n">atoms</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">el</span> <span class="o">=</span> <span class="n">cc</span><span class="p">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">el</span><span class="p">;</span>
    <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="n">cc</span><span class="p">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">Restraints</span><span class="o">::</span><span class="n">Bond</span><span class="o">&amp;</span> <span class="nl">bond</span> <span class="p">:</span> <span class="n">cc</span><span class="p">.</span><span class="n">rt</span><span class="p">.</span><span class="n">bonds</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">cc</span><span class="p">.</span><span class="n">get_atom_index</span><span class="p">(</span><span class="n">bond</span><span class="p">.</span><span class="n">id1</span><span class="p">.</span><span class="n">atom</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">cc</span><span class="p">.</span><span class="n">get_atom_index</span><span class="p">(</span><span class="n">bond</span><span class="p">.</span><span class="n">id2</span><span class="p">.</span><span class="n">atom</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">add_edge</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">BondEdge</span><span class="p">{</span><span class="n">bond</span><span class="p">.</span><span class="n">type</span><span class="p">},</span> <span class="n">g</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">g</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And here we use NetworkX in Python:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">cif</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;../tests/SO3.cif&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">so3</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">make_chemcomp_from_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">so3</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">el</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">so3</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">id1</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">id2</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>  <span class="c1"># ignoring bond type</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>To show a quick example, let us count automorphisms of SO3:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx.algorithms.isomorphism</span> <span class="k">as</span> <span class="nn">iso</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GM</span> <span class="o">=</span> <span class="n">iso</span><span class="o">.</span><span class="n">GraphMatcher</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">node_match</span><span class="o">=</span><span class="n">iso</span><span class="o">.</span><span class="n">categorical_node_match</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># expecting 3! automorphisms (permutations of the three oxygens)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">GM</span><span class="o">.</span><span class="n">isomorphisms_iter</span><span class="p">())</span>
<span class="go">6</span>
</pre></div>
</div>
<p>With a bit more of code we could perform a real cheminformatics task.</p>
<div class="section" id="graph-isomorphism">
<span id="id3"></span><h3>Graph isomorphism<a class="headerlink" href="#graph-isomorphism" title="Permalink to this headline">¶</a></h3>
<p>In this example we use Python NetworkX to compare molecules from the
Refmac monomer library with Chemical Component Dictionary (CCD) from PDB.
The same could be done with other graph analysis libraries,
such as Boost Graph Library, igraph, etc.</p>
<p>The program below takes compares specified monomer cif files with
corresponding CCD entries. Hydrogens and bond types are ignored.
It takes less than half a minute to go through the 25,000 monomer
files distributed with CCP4 (as of Oct 2018),
so we do not try to optimize the program.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compares graphs of molecules from cif files (Refmac dictionary or similar)</span>
<span class="c1"># with CCD entries.</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">networkx</span>
<span class="kn">from</span> <span class="nn">networkx.algorithms</span> <span class="kn">import</span> <span class="n">isomorphism</span>
<span class="kn">import</span> <span class="nn">gemmi</span>

<span class="n">CCD_PATH</span> <span class="o">=</span> <span class="s1">&#39;components.cif.gz&#39;</span>

<span class="k">def</span> <span class="nf">graph_from_chemcomp</span><span class="p">(</span><span class="n">cc</span><span class="p">):</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">cc</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">el</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">cc</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">id1</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">id2</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span>

<span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">):</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cc1</span><span class="o">.</span><span class="n">atoms</span><span class="p">}</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cc2</span><span class="o">.</span><span class="n">atoms</span><span class="p">}</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="o">.</span><span class="n">lexicographic_str</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">cc1</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">bonds</span><span class="p">}</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="o">.</span><span class="n">lexicographic_str</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">cc2</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">bonds</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span> <span class="ow">and</span> <span class="n">b1</span> <span class="o">==</span> <span class="n">b2</span><span class="p">:</span>
        <span class="c1">#print(cc1.name, &quot;the same&quot;)</span>
        <span class="k">return</span>
    <span class="n">G1</span> <span class="o">=</span> <span class="n">graph_from_chemcomp</span><span class="p">(</span><span class="n">cc1</span><span class="p">)</span>
    <span class="n">G2</span> <span class="o">=</span> <span class="n">graph_from_chemcomp</span><span class="p">(</span><span class="n">cc2</span><span class="p">)</span>
    <span class="n">node_match</span> <span class="o">=</span> <span class="n">isomorphism</span><span class="o">.</span><span class="n">categorical_node_match</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">GM</span> <span class="o">=</span> <span class="n">isomorphism</span><span class="o">.</span><span class="n">GraphMatcher</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">G2</span><span class="p">,</span> <span class="n">node_match</span><span class="o">=</span><span class="n">node_match</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">GM</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cc1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;is isomorphic&#39;</span><span class="p">)</span>
        <span class="c1"># we could use GM.match(), but here we try to find the shortest diff</span>
        <span class="n">short_diff</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">GM</span><span class="o">.</span><span class="n">isomorphisms_iter</span><span class="p">()):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">v</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">short_diff</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">short_diff</span><span class="p">):</span>
                <span class="n">short_diff</span> <span class="o">=</span> <span class="n">diff</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">10000</span><span class="p">:</span>  <span class="c1"># don&#39;t spend too much here</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; (it may not be the simplest isomorphism)&#39;</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">for</span> <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span> <span class="ow">in</span> <span class="n">short_diff</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="s1">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="n">id2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cc1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;differs&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s2</span> <span class="o">-</span> <span class="n">s1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">missing:&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s2</span> <span class="o">-</span> <span class="n">s1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">s2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">extra:  &#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s1</span> <span class="o">-</span> <span class="n">s2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">ccd</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">cif</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">CCD_PATH</span><span class="p">)</span>
    <span class="n">absent</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">cif</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cc1</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">make_chemcomp_from_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">block2</span> <span class="o">=</span> <span class="n">ccd</span><span class="p">[</span><span class="n">cc1</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">absent</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">#print(cc1.name, &#39;not in CCD&#39;)</span>
            <span class="k">continue</span>
        <span class="n">cc2</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">make_chemcomp_from_block</span><span class="p">(</span><span class="n">block2</span><span class="p">)</span>
        <span class="n">cc1</span><span class="o">.</span><span class="n">remove_hydrogens</span><span class="p">()</span>
        <span class="n">cc2</span><span class="o">.</span><span class="n">remove_hydrogens</span><span class="p">()</span>
        <span class="n">compare</span><span class="p">(</span><span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absent</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">absent</span><span class="p">,</span> <span class="s1">&#39;of&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;monomers not found in CCD&#39;</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>If we run it on monomers that start with M we get:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> examples/ccd_gi.py <span class="nv">$CLIBD_MON</span>/m/*.cif
<span class="go">M10 is isomorphic</span>
<span class="go">       O9 -&gt; O4</span>
<span class="go">       O4 -&gt; O9</span>
<span class="go">MK8 is isomorphic</span>
<span class="go">       O2 -&gt; OXT</span>
<span class="go">MMR differs</span>
<span class="go">      missing: O12 O4</span>
<span class="go">2 of 821 monomers not found in CCD</span>
</pre></div>
</div>
<p>So in M10 the two atoms marked green are swapped:</p>
<a class="reference internal image-reference" href="_images/M10-isomorphism.png"><img alt="_images/M10-isomorphism.png" class="align-center" src="_images/M10-isomorphism.png" style="width: 260.0px; height: 238.0px;" /></a>
<p>(The image was generated in NGL and compressed with Compress-Or-Die.)</p>
</div>
<div class="section" id="substructure-matching">
<span id="id4"></span><h3>Substructure matching<a class="headerlink" href="#substructure-matching" title="Permalink to this headline">¶</a></h3>
<p>Now a little script to illustrate subgraph isomorphism.
The script takes a (three-letter-)code of a molecule that is to be used
as a pattern and finds CCD entries that contain such a a substructure.
As in the previous example, hydrogens and bond types are ignored.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># List CCD entries that contain the specified entry as a substructure.</span>
<span class="c1"># Ignoring hydrogens and bond types.</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">networkx</span>
<span class="kn">from</span> <span class="nn">networkx.algorithms</span> <span class="kn">import</span> <span class="n">isomorphism</span>
<span class="kn">import</span> <span class="nn">gemmi</span>

<span class="n">CCD_PATH</span> <span class="o">=</span> <span class="s1">&#39;components.cif.gz&#39;</span>

<span class="k">def</span> <span class="nf">graph_from_block</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">make_chemcomp_from_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
    <span class="n">cc</span><span class="o">.</span><span class="n">remove_hydrogens</span><span class="p">()</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">cc</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">el</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">cc</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">id1</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">id2</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Usage: ccd_subgraph.py three-letter-code&quot;</span>
    <span class="n">ccd</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">cif</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">CCD_PATH</span><span class="p">)</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">graph_from_block</span><span class="p">(</span><span class="n">ccd</span><span class="p">[</span><span class="n">entry</span><span class="p">])</span>
    <span class="n">pattern_nodes</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">pattern_edges</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">node_match</span> <span class="o">=</span> <span class="n">isomorphism</span><span class="o">.</span><span class="n">categorical_node_match</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">ccd</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">graph_from_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">GM</span> <span class="o">=</span> <span class="n">isomorphism</span><span class="o">.</span><span class="n">GraphMatcher</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">node_match</span><span class="o">=</span><span class="n">node_match</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">GM</span><span class="o">.</span><span class="n">subgraph_is_isomorphic</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> +</span><span class="si">%d</span><span class="s1"> nodes, +</span><span class="si">%d</span><span class="s1"> edges&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">networkx</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">-</span> <span class="n">pattern_nodes</span><span class="p">,</span>
                <span class="n">networkx</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">-</span> <span class="n">pattern_edges</span><span class="p">))</span>

<span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Let us check what entries have HEM as a substructure:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> examples/ccd_subgraph.py HEM
<span class="go">1FH    +6 nodes, +7 edges</span>
<span class="go">2FH    +6 nodes, +7 edges</span>
<span class="go">4HE    +7 nodes, +8 edges</span>
<span class="go">522    +2 nodes, +2 edges</span>
<span class="go">6CO    +6 nodes, +7 edges</span>
<span class="go">6CQ    +7 nodes, +8 edges</span>
<span class="go">89R    +3 nodes, +3 edges</span>
<span class="go">CLN    +1 nodes, +2 edges</span>
<span class="go">DDH    +2 nodes, +2 edges</span>
<span class="go">FEC    +6 nodes, +6 edges</span>
<span class="go">HAS    +22 nodes, +22 edges</span>
<span class="go">HCO    +1 nodes, +1 edges</span>
<span class="go">HDM    +2 nodes, +2 edges</span>
<span class="go">HEA    +17 nodes, +17 edges</span>
<span class="go">HEB    +0 nodes, +0 edges</span>
<span class="go">HEC    +0 nodes, +0 edges</span>
<span class="go">HEM    +0 nodes, +0 edges</span>
<span class="go">HEO    +16 nodes, +16 edges</span>
<span class="go">HEV    +2 nodes, +2 edges</span>
<span class="go">HP5    +2 nodes, +2 edges</span>
<span class="go">ISW    +0 nodes, +0 edges</span>
<span class="go">MH0    +0 nodes, +0 edges</span>
<span class="go">MHM    +0 nodes, +0 edges</span>
<span class="go">N7H    +3 nodes, +3 edges</span>
<span class="go">NTE    +3 nodes, +3 edges</span>
<span class="go">OBV    +14 nodes, +14 edges</span>
<span class="go">SRM    +20 nodes, +20 edges</span>
<span class="go">UFE    +18 nodes, +18 edges</span>
</pre></div>
</div>
</div>
<div class="section" id="maximum-common-subgraph">
<span id="id5"></span><h3>Maximum common subgraph<a class="headerlink" href="#maximum-common-subgraph" title="Permalink to this headline">¶</a></h3>
<p>In this example we use McGregor’s algorithm implemented in the Boost Graph
Library to find maximum common induced subgraph. We call the MCS searching
function with option <code class="docutils literal notranslate"><span class="pre">only_connected_subgraphs=true</span></code>, which has obvious
meaning and can be changed if needed.</p>
<p>To illustrate this example, we compare ligands AUD and LSA:</p>
<a class="reference internal image-reference" href="_images/aud_lsa.png"><img alt="_images/aud_lsa.png" class="align-center" src="_images/aud_lsa.png" style="width: 422.0px; height: 156.0px;" /></a>
<p>The whole code is in <code class="file docutils literal notranslate"><span class="pre">examples/with_bgl.cpp</span></code>. The same file has also
examples of using the BGL implementation of VF2 to check graph
and subgraph isomorphisms.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// We ignore hydrogens here.</span>
<span class="c1">// Example output:</span>
<span class="c1">//   $ time with_bgl -c monomers/a/AUD.cif monomers/l/LSA.cif</span>
<span class="c1">//   Searching largest subgraphs of AUD and LSA (10 and 12 vertices)...</span>
<span class="c1">//   Maximum connected common subgraph has 7 vertices:</span>
<span class="c1">//     SAA -&gt; S10</span>
<span class="c1">//     OAG -&gt; O12</span>
<span class="c1">//     OAH -&gt; O11</span>
<span class="c1">//     NAF -&gt; N9</span>
<span class="c1">//     CAE -&gt; C7</span>
<span class="c1">//     OAI -&gt; O8</span>
<span class="c1">//     CAD -&gt; C1</span>
<span class="c1">//   Maximum connected common subgraph has 7 vertices:</span>
<span class="c1">//     SAA -&gt; S10</span>
<span class="c1">//     OAG -&gt; O11</span>
<span class="c1">//     OAH -&gt; O12</span>
<span class="c1">//     NAF -&gt; N9</span>
<span class="c1">//     CAE -&gt; C7</span>
<span class="c1">//     OAI -&gt; O8</span>
<span class="c1">//     CAD -&gt; C1</span>
<span class="c1">//   </span>
<span class="c1">//   real	0m0.012s</span>
<span class="c1">//   user	0m0.008s</span>
<span class="c1">//   sys	0m0.004s</span>

<span class="k">struct</span> <span class="n">PrintCommonSubgraphCallback</span> <span class="p">{</span>
  <span class="n">Graph</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CorrespondenceMap1To2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CorrespondenceMap2To1</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">CorrespondenceMap1To2</span> <span class="n">map1</span><span class="p">,</span> <span class="n">CorrespondenceMap2To1</span><span class="p">,</span>
                  <span class="k">typename</span> <span class="n">GraphTraits</span><span class="o">::</span><span class="n">vertices_size_type</span> <span class="n">subgraph_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Maximum connected common subgraph has &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">subgraph_size</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; vertices:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">vp</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">vertices</span><span class="p">(</span><span class="n">g1</span><span class="p">);</span> <span class="n">vp</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">vp</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="o">++</span><span class="n">vp</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Vertex</span> <span class="n">v1</span> <span class="o">=</span> <span class="o">*</span><span class="n">vp</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
      <span class="n">Vertex</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">map1</span><span class="p">,</span> <span class="n">v1</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">!=</span> <span class="n">GraphTraits</span><span class="o">::</span><span class="n">null_vertex</span><span class="p">())</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">g1</span><span class="p">[</span><span class="n">v1</span><span class="p">].</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">g2</span><span class="p">[</span><span class="n">v2</span><span class="p">].</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">find_common_subgraph</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cif1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cif2</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">gemmi</span><span class="o">::</span><span class="n">ChemComp</span> <span class="n">cc1</span> <span class="o">=</span> <span class="n">make_chemcomp</span><span class="p">(</span><span class="n">cif1</span><span class="p">).</span><span class="n">remove_hydrogens</span><span class="p">();</span>
  <span class="n">Graph</span> <span class="n">graph1</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="n">cc1</span><span class="p">);</span>
  <span class="n">gemmi</span><span class="o">::</span><span class="n">ChemComp</span> <span class="n">cc2</span> <span class="o">=</span> <span class="n">make_chemcomp</span><span class="p">(</span><span class="n">cif2</span><span class="p">).</span><span class="n">remove_hydrogens</span><span class="p">();</span>
  <span class="n">Graph</span> <span class="n">graph2</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="n">cc2</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Searching largest subgraphs of &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cc1</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; and &quot;</span>
      <span class="o">&lt;&lt;</span> <span class="n">cc2</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; (&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cc1</span><span class="p">.</span><span class="n">atoms</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; and &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cc2</span><span class="p">.</span><span class="n">atoms</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot; vertices)...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">mcgregor_common_subgraphs_maximum_unique</span><span class="p">(</span>
      <span class="n">graph1</span><span class="p">,</span> <span class="n">graph2</span><span class="p">,</span>
      <span class="n">get</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">vertex_index</span><span class="p">,</span> <span class="n">graph1</span><span class="p">),</span> <span class="n">get</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">vertex_index</span><span class="p">,</span> <span class="n">graph2</span><span class="p">),</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Edge</span> <span class="n">a</span><span class="p">,</span> <span class="n">Edge</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">graph1</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">graph2</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">type</span><span class="p">;</span> <span class="p">},</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Vertex</span> <span class="n">a</span><span class="p">,</span> <span class="n">Vertex</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">graph1</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">el</span> <span class="o">==</span> <span class="n">graph2</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">el</span><span class="p">;</span> <span class="p">},</span>
      <span class="cm">/*only_connected_subgraphs=*/</span> <span class="nb">true</span><span class="p">,</span>
      <span class="n">PrintCommonSubgraphCallback</span><span class="p">{</span><span class="n">graph1</span><span class="p">,</span> <span class="n">graph2</span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="torsion-angles">
<h2>Torsion Angles<a class="headerlink" href="#torsion-angles" title="Permalink to this headline">¶</a></h2>
<p>This section presents functions dedicated to calculation of the dihedral angles
φ (phi), ψ (psi) and ω (omega) of the protein backbone.
These functions are built upon the more general <code class="docutils literal notranslate"><span class="pre">calculate_dihedral</span></code> function,
introduced in <a class="reference internal" href="mol.html#coordinates"><span class="std std-ref">the section about coordinates</span></a>,
which takes four points in the space as arguments.</p>
<p><code class="docutils literal notranslate"><span class="pre">calculate_omega()</span></code> calculates the ω angle, which is usually around 180°:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">degrees</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/5cvz_final.pdb&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">degrees</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">calculate_omega</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">chain</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">159.90922150065668</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">next_res</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">next_residue</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">next_res</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">omega</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">calculate_omega</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">next_res</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">degrees</span><span class="p">(</span><span class="n">omega</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">ALA 159.90922150065668</span>
<span class="go">ALA -165.26874513591105</span>
<span class="go">ALA -165.85686681169656</span>
<span class="go">THR -172.99968385093513</span>
<span class="go">SER 176.74223937657646</span>
</pre></div>
</div>
<p>The φ and ψ angles are often used together, so they are calculated
in one function <code class="docutils literal notranslate"><span class="pre">calculate_phi_psi()</span></code>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">prev_res</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">previous_residue</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">next_res</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">next_residue</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">phi</span><span class="p">,</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">calculate_phi_psi</span><span class="p">(</span><span class="n">prev_res</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">next_res</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%8.2f</span><span class="s1"> </span><span class="si">%8.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">degrees</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">degrees</span><span class="p">(</span><span class="n">psi</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="go">ALA      nan   106.94</span>
<span class="go">ALA  -116.64    84.57</span>
<span class="go">ALA   -45.57   127.40</span>
<span class="go">THR   -62.01   147.45</span>
<span class="go">SER   -92.85   161.53</span>
</pre></div>
</div>
<p>In C++ these functions can be found in <code class="docutils literal notranslate"><span class="pre">gemmi/calculate.hpp</span></code>.</p>
<p>The torsion angles φ and ψ can be visualized on the Ramachandran plot.
Let us plot angles from all PDB entries with the resolution higher than 1.5A.
Usually, glycine, proline and the residue preceding proline (pre-proline)
are plotted separately. Here, we will exclude pre-proline and make
separate plot for each amino acid. So first, we calculate angles
and save φ,ψ pairs in a set of files – one file per residue.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">degrees</span>
<span class="kn">import</span> <span class="nn">gemmi</span>

<span class="n">ramas</span> <span class="o">=</span> <span class="p">{</span><span class="n">aa</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="p">[</span>
    <span class="s1">&#39;LEU&#39;</span><span class="p">,</span> <span class="s1">&#39;ALA&#39;</span><span class="p">,</span> <span class="s1">&#39;GLY&#39;</span><span class="p">,</span> <span class="s1">&#39;VAL&#39;</span><span class="p">,</span> <span class="s1">&#39;GLU&#39;</span><span class="p">,</span> <span class="s1">&#39;SER&#39;</span><span class="p">,</span> <span class="s1">&#39;LYS&#39;</span><span class="p">,</span> <span class="s1">&#39;ASP&#39;</span><span class="p">,</span> <span class="s1">&#39;THR&#39;</span><span class="p">,</span> <span class="s1">&#39;ILE&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ARG&#39;</span><span class="p">,</span> <span class="s1">&#39;PRO&#39;</span><span class="p">,</span> <span class="s1">&#39;ASN&#39;</span><span class="p">,</span> <span class="s1">&#39;PHE&#39;</span><span class="p">,</span> <span class="s1">&#39;GLN&#39;</span><span class="p">,</span> <span class="s1">&#39;TYR&#39;</span><span class="p">,</span> <span class="s1">&#39;HIS&#39;</span><span class="p">,</span> <span class="s1">&#39;MET&#39;</span><span class="p">,</span> <span class="s1">&#39;CYS&#39;</span><span class="p">,</span> <span class="s1">&#39;TRP&#39;</span><span class="p">]}</span>

<span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">CoorFileWalk</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="mf">0.1</span> <span class="o">&lt;</span> <span class="n">st</span><span class="o">.</span><span class="n">resolution</span> <span class="o">&lt;</span> <span class="mf">1.5</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_polymer</span><span class="p">():</span>
                <span class="c1"># previous_residue() and next_residue() return previous/next</span>
                <span class="c1"># residue only if the residues are bonded. Otherwise -- None.</span>
                <span class="n">prev_res</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">previous_residue</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                <span class="n">next_res</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">next_residue</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">prev_res</span> <span class="ow">and</span> <span class="n">next_res</span> <span class="ow">and</span> <span class="n">next_res</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;PRO&#39;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">calculate_phi_psi</span><span class="p">(</span><span class="n">prev_res</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">next_res</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ramas</span><span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>

<span class="c1"># Write data to files</span>
<span class="k">for</span> <span class="n">aa</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">ramas</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;ramas/&#39;</span> <span class="o">+</span> <span class="n">aa</span> <span class="o">+</span> <span class="s1">&#39;.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">phi</span><span class="p">,</span> <span class="n">psi</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.4f</span><span class="se">\t</span><span class="si">%.4f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">degrees</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">degrees</span><span class="p">(</span><span class="n">psi</span><span class="p">)))</span>
</pre></div>
</div>
<p>The script above works with coordinate files in any of the formats
supported by gemmi (PDB, mmCIF, mmJSON). As of 2019, processing
a <a class="reference internal" href="#pdb-dir"><span class="std std-ref">local copy of the PDB archive</span></a>
in the PDB format takes about 20 minutes.</p>
<p>In the second step we plot the data points with matplotlib.
We use a script that can be found in <code class="file docutils literal notranslate"><span class="pre">examples/rama_gather.py</span></code>.
Six of the resulting plots are shown here (click to enlarge):</p>
<a class="reference internal image-reference" href="_images/ramachandran-per-aa.png"><img alt="_images/ramachandran-per-aa.png" class="align-center" src="_images/ramachandran-per-aa.png" style="width: 630.0px; height: 428.4px;" /></a>
</div>
<div class="section" id="local-copy-of-the-pdb-archive">
<span id="pdb-dir"></span><h2>Local copy of the PDB archive<a class="headerlink" href="#local-copy-of-the-pdb-archive" title="Permalink to this headline">¶</a></h2>
<p>Some examples in this documentation work on a local copy
of the Protein Data Bank archive. This subsection is actually
a footnote describing our setup.</p>
<p>Like in BioJava, we assume that the <code class="docutils literal notranslate"><span class="pre">$PDB_DIR</span></code> environment variable
points to a directory that contains <code class="docutils literal notranslate"><span class="pre">structures/divided/mmCIF</span></code> – the same
arrangement as on the
<a class="reference external" href="ftp://ftp.wwpdb.org/pub/pdb/data/structures/">PDB’s FTP</a> server.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">cd</span> <span class="nv">$PDB_DIR</span>
<span class="gp">$</span> du -sh structures/*/*  <span class="c1"># as of Jun 2017</span>
<span class="go">34G    structures/divided/mmCIF</span>
<span class="go">25G    structures/divided/pdb</span>
<span class="go">101G   structures/divided/structure_factors</span>
<span class="go">2.6G   structures/obsolete/mmCIF</span>
</pre></div>
</div>
<p>A traditional way to keep an up-to-date local archive is to rsync it
once a week:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh -x</span>
<span class="nb">set</span> -u  <span class="c1"># PDB_DIR must be defined</span>
rsync_subdir<span class="o">()</span> <span class="o">{</span>
  mkdir -p <span class="s2">&quot;</span><span class="nv">$PDB_DIR</span><span class="s2">/</span><span class="nv">$1</span><span class="s2">&quot;</span>
  <span class="c1"># Using PDBe (UK) here, can be replaced with RCSB (USA) or PDBj (Japan),</span>
  <span class="c1"># see https://www.wwpdb.org/download/downloads</span>
  rsync -rlpt -v -z --delete <span class="se">\</span>
      rsync.ebi.ac.uk::pub/databases/pdb/data/<span class="nv">$1</span>/ <span class="s2">&quot;</span><span class="nv">$PDB_DIR</span><span class="s2">/</span><span class="nv">$1</span><span class="s2">/&quot;</span>
<span class="o">}</span>
rsync_subdir structures/divided/mmCIF
<span class="c1">#rsync_subdir structures/obsolete/mmCIF</span>
<span class="c1">#rsync_subdir structures/divided/pdb</span>
<span class="c1">#rsync_subdir structures/divided/structure_factors</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="grid.html" class="btn btn-neutral float-right" title="Grids and maps" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mol.html" class="btn btn-neutral float-left" title="Molecular models" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2020 Global Phasing Ltd

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>