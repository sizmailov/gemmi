

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Molecular models &mdash; Gemmi 0.3.7 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Structure analysis" href="analysis.html" />
    <link rel="prev" title="Symmetry" href="symmetry.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Gemmi
          

          
          </a>

          
            
            
              <div class="version">
                0.3.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cif.html">CIF Parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="symmetry.html">Symmetry</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Molecular models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#elements">Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#small-molecules">Small Molecules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#chemical-components">Chemical Components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#built-in-data">Built-in data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ccd-and-monomer-libraries">CCD and monomer libraries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#coordinates-and-matrices">Coordinates and matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unit-cell">Unit Cell</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reading-coordinate-files">Reading coordinate files</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#c">C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="#python">Python</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pdb-format">PDB format</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reading">Reading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing">Writing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pdbx-mmcif-format">PDBx/mmCIF format</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">Reading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Writing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mmjson-format">mmJSON format</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">Reading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">Writing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hierarchy">Hierarchy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#naming">Naming</a></li>
<li class="toctree-l3"><a class="reference internal" href="#alternative-conformations">Alternative conformations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#discontinuous-chains">Discontinuous chains</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#structure">Structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#entity">Entity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connection">Connection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assembly">Assembly</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-operations">Common operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sequence">Sequence</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#molecular-weight">Molecular weight</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sequence-alignment">Sequence alignment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#model">Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#chain">Chain</a></li>
<li class="toctree-l2"><a class="reference internal" href="#residuespan-residuegroup">ResidueSpan, ResidueGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#residue">Residue</a></li>
<li class="toctree-l2"><a class="reference internal" href="#atomgroup">AtomGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#atom">Atom</a></li>
<li class="toctree-l2"><a class="reference internal" href="#atomaddress-and-cra">AtomAddress and CRA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#chain-longer-than-cell">Chain longer than cell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ccd-subset">CCD subset</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="analysis.html">Structure analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="grid.html">Grids and maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="hkl.html">Reciprocal space</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Gemmi program</a></li>
<li class="toctree-l1"><a class="reference external" href="https://project-gemmi.github.io/gemmi/api/python">Python API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Gemmi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Molecular models</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/mol.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="molecular-models">
<span id="molecular"></span><h1>Molecular models<a class="headerlink" href="#molecular-models" title="Permalink to this headline">¶</a></h1>
<p>In this section we show how to handle structural models of
biomolecules (to some degree, it also applies to small molecules
and inorganic structures).</p>
<p>Models from a single file (PDB, mmCIF, etc.) are stored in the <code class="docutils literal notranslate"><span class="pre">Structure</span></code>
class, with the usual Model-Chain-Residue-Atom hierarchy.
Gemmi provides basic functions to access and manipulate the structure,
and on top of it more complex functions, such as
neighbor search, calculation of dihedral angles, removal of ligands from
a model, etc.</p>
<p>Comparing with tools rooted in bioinformatics:</p>
<ul class="simple">
<li><p>Gemmi focuses more on working with incomplete models
(on all stages before they are published and submitted to the PDB),</p></li>
<li><p>and Gemmi is aware of the neighbouring molecules that are implied by
the crystallographic and non-crystallographic symmetry.</p></li>
</ul>
<div class="section" id="elements">
<span id="id1"></span><h2>Elements<a class="headerlink" href="#elements" title="Permalink to this headline">¶</a></h2>
<p>When working with molecular structures it is good to have basic data
from the periodic table at hand.</p>
<p><strong>C++</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/elem.hpp&gt;</span><span class="cp"></span>

<span class="n">gemmi</span><span class="o">::</span><span class="n">Element</span> <span class="n">el</span><span class="p">(</span><span class="s">&quot;Mg&quot;</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">its_number</span> <span class="o">=</span> <span class="n">el</span><span class="p">.</span><span class="n">atomic_number</span><span class="p">();</span>
<span class="kt">double</span> <span class="n">its_weight</span> <span class="o">=</span> <span class="n">el</span><span class="p">.</span><span class="n">weight</span><span class="p">();</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">its_name</span> <span class="o">=</span> <span class="n">el</span><span class="p">.</span><span class="n">name</span><span class="p">();</span>
</pre></div>
</div>
<p><strong>Python</strong></p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gemmi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;Mg&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">weight</span>
<span class="go">24.305</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="mi">118</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;Og&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;Mo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">atomic_number</span>
<span class="go">42</span>
</pre></div>
</div>
<p id="covalent-radius">We also included covalent radii of elements from a
<a class="reference external" href="https://en.wikipedia.org/wiki/Covalent_radius">Wikipedia page</a>,
which has data from
Cordero <em>et al</em> (2008), <em>Covalent radii revisited</em>, Dalton Trans. 21, 2832.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;Zr&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_r</span>
<span class="go">1.75</span>
</pre></div>
</div>
<p>and a flag for metals (the classification is somewhat arbitrary):</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;Mg&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_metal</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_metal</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="small-molecules">
<h2>Small Molecules<a class="headerlink" href="#small-molecules" title="Permalink to this headline">¶</a></h2>
<p>CIF files that describe small-molecule and inorganic structures
can be read into an SmallStructure object.
Unlike macromolecular Structure, SmallStructure has no hierarchy.
It is just a flat list of atomic sites (<code class="docutils literal notranslate"><span class="pre">SmallStructure::Site</span></code>)
together with the unit cell and symmetry.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/cif.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/smcif.hpp&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">block</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">cif</span><span class="o">::</span><span class="n">read_file</span><span class="p">(</span><span class="s">&quot;1011031.cif&quot;</span><span class="p">).</span><span class="n">sole_block</span><span class="p">();</span>
  <span class="n">gemmi</span><span class="o">::</span><span class="n">SmallStructure</span> <span class="n">SiC</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">make_small_structure_from_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">SiC</span><span class="p">.</span><span class="n">cell</span><span class="p">.</span><span class="n">a</span> <span class="o">==</span> <span class="mf">4.358</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">SiC</span><span class="p">.</span><span class="n">spacegroup_hm</span> <span class="o">==</span> <span class="s">&quot;F -4 3 m&quot;</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">SiC</span><span class="p">.</span><span class="n">sites</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">SiC</span><span class="p">.</span><span class="n">get_all_unit_cell_sites</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gemmi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SiC</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_small_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1011031.cif&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SiC</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">a</span>
<span class="go">4.358</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SiC</span><span class="o">.</span><span class="n">spacegroup_hm</span>
<span class="go">&#39;F -4 3 m&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SiC</span><span class="o">.</span><span class="n">sites</span>
<span class="go">[&lt;gemmi.SmallStructure.Site Si1&gt;, &lt;gemmi.SmallStructure.Site C1&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">SiC</span><span class="o">.</span><span class="n">get_all_unit_cell_sites</span><span class="p">())</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">site</span> <span class="o">=</span> <span class="n">SiC</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">site</span><span class="o">.</span><span class="n">label</span>
<span class="go">&#39;Si1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">site</span><span class="o">.</span><span class="n">type_symbol</span>
<span class="go">&#39;Si4+&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">site</span><span class="o">.</span><span class="n">fract</span>
<span class="go">&lt;gemmi.Fractional(0, 0, 0)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">site</span><span class="o">.</span><span class="n">occ</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">site</span><span class="o">.</span><span class="n">u_iso</span>  <span class="c1"># not specified here</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">site</span><span class="o">.</span><span class="n">element</span>  <span class="c1"># obtained from type_symbol &#39;Si4+&#39;</span>
<span class="go">&lt;gemmi.Element: Si&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">site</span><span class="o">.</span><span class="n">charge</span>   <span class="c1"># obtained from type_symbol &#39;Si4+&#39;</span>
<span class="go">4</span>
</pre></div>
</div>
<p>We will need another cif file to show anisotropic ADPs and disorder_group:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">perovskite</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_small_structure</span><span class="p">(</span><span class="s1">&#39;../tests/4003024.cif&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">perovskite</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(),</span> <span class="n">site</span><span class="o">.</span><span class="n">disorder_group</span> <span class="ow">or</span> <span class="s1">&#39;n/a&#39;</span><span class="p">)</span>
<span class="go">Cs1 True n/a</span>
<span class="go">Sn2 False 1</span>
<span class="go">Cl1 True n/a</span>
<span class="go">In False 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perovskite</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u11</span>
<span class="go">0.10300000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perovskite</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u22</span>
<span class="go">0.15600000000000003</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perovskite</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u33</span>
<span class="go">0.15600000000000003</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perovskite</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u12</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perovskite</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u13</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perovskite</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u23</span>
<span class="go">0.0</span>
</pre></div>
</div>
</div>
<div class="section" id="chemical-components">
<span id="chemcomp"></span><h2>Chemical Components<a class="headerlink" href="#chemical-components" title="Permalink to this headline">¶</a></h2>
<p>Residues (monomers) and small molecule components of macromolecular models
are called <em>chemical components</em>.
Gemmi can use three sources of knowledge about chemical components:</p>
<ul class="simple">
<li><p>built-in basic data about 350+ popular components,</p></li>
<li><p>the Chemical Component Dictionary (CCD) maintained by the PDB
(25,000+ components),</p></li>
<li><p>so-called CIF files compatible with the format of the Refmac/CCP4 monomer
library.</p></li>
</ul>
<div class="section" id="built-in-data">
<span id="find-tabulated-residue"></span><h3>Built-in data<a class="headerlink" href="#built-in-data" title="Permalink to this headline">¶</a></h3>
<p>The built-in data is accessed through the function <code class="docutils literal notranslate"><span class="pre">find_tabulated_residue</span></code>.
It contains only minimal information about each residue:
assigned category, the “standard” flag (non-standard residues are marked
as HETATM in the PDB, even in polymer), one-letter code,
the number of hydrogens and molecular weight:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/resinfo.hpp&gt;</span><span class="cp"></span>

<span class="n">gemmi</span><span class="o">::</span><span class="n">ResidueInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">find_tabulated_residue</span><span class="p">(</span><span class="s">&quot;ALA&quot;</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">is_it_aminoacid</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">is_amino_acid</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">approximate_number_of_h_atoms</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">hydrogen_count</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gln</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">find_tabulated_residue</span><span class="p">(</span><span class="s1">&#39;GLN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gln</span><span class="o">.</span><span class="n">is_amino_acid</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gln</span><span class="o">.</span><span class="n">one_letter_code</span>
<span class="go">&#39;Q&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">gln</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">146.144</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gln</span><span class="o">.</span><span class="n">hydrogen_count</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">find_tabulated_residue</span><span class="p">(</span><span class="s1">&#39;DOD&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_water</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># PDB marks &quot;non-standard&quot; residues as HETATM.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Pyrrolysine is standard - some microbes have it.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">find_tabulated_residue</span><span class="p">(</span><span class="s1">&#39;PYL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_standard</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">find_tabulated_residue</span><span class="p">(</span><span class="s1">&#39;MSE&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_standard</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="ccd-and-monomer-libraries">
<span id="ccd-etc"></span><h3>CCD and monomer libraries<a class="headerlink" href="#ccd-and-monomer-libraries" title="Permalink to this headline">¶</a></h3>
<p>To get more complete information, including atoms and bonds in the monomer,
we need to first read either the <a class="reference external" href="https://www.wwpdb.org/data/ccd">CCD</a>
or a monomer library.</p>
<p>The CCD <code class="file docutils literal notranslate"><span class="pre">components.cif</span></code> file describes all the monomers
(residues, ligands, solvent molecules) from the PDB entries.
Importantly, it contains information about bonds.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The absence of bond information in mmCIF files from wwPDB is a
<a class="reference external" href="https://www.cgl.ucsf.edu/chimera/data/mmcif-oct2013/mmcif.html">well-known problem</a>,
mitigated somewhat by PDBe which in parallel to the wwPDB archive has also
<a class="reference external" href="https://doi.org/10.1093/nar/gkv1047">mmCIF files with connectivity</a>
and bond-order information;
and by RCSB which has this information in the
<a class="reference external" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5473584/#__tag_618683893">MMTF format</a>.</p>
</div>
<p>Macromolecular refinement programs need to know more about monomers
than the CCD can tell: they need to know how to restrain the structure.
Therefore, they have own dictionaries of monomers (a.k.a monomer libraries),
such as the Refmac dictionary, where each monomer is described by one cif file.
These libraries are often complemented by user’s own cif files.</p>
<p>Gemmi has class <code class="docutils literal notranslate"><span class="pre">ChemComp</span></code> that corresponds to the data about a monomer
from either the CCD or a cif file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/cif.hpp&gt;             // for cif::read_file</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/chemcomp.hpp&gt;        // for ChemComp, make_chemcomp_from_block</span><span class="cp"></span>

<span class="n">gemmi</span><span class="o">::</span><span class="n">ChemComp</span> <span class="n">make_chemcomp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">gemmi</span><span class="o">::</span><span class="n">cif</span><span class="o">::</span><span class="n">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">cif</span><span class="o">::</span><span class="n">read_file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
  <span class="c1">// assuming the component description is in the last block of the file</span>
  <span class="k">return</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">make_chemcomp_from_block</span><span class="p">(</span><span class="n">doc</span><span class="p">.</span><span class="n">blocks</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># SO3.cif -&gt; gemmi.ChemComp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">cif</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;../tests/SO3.cif&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">so3</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">make_chemcomp_from_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</pre></div>
</div>
<p>It also has class <code class="docutils literal notranslate"><span class="pre">MonLib</span></code> that corresponds to a monomer library.
In addition to storing a mapping between residue names and <code class="docutils literal notranslate"><span class="pre">ChemComp</span></code>s,
it also stores information that in the CCP4 monomer library is kept in
<code class="file docutils literal notranslate"><span class="pre">mon_lib_list.cif</span></code>: description of chemical links and modifications,
and classification of the residues.</p>
<p>These classes are not documented yet.
The examples in <a class="reference internal" href="analysis.html#graph-analysis"><span class="std std-ref">Graph analysis</span></a>
show how to access the lists of atoms and bonds from <code class="docutils literal notranslate"><span class="pre">ChemComp</span></code>.</p>
</div>
</div>
<div class="section" id="coordinates-and-matrices">
<span id="coordinates"></span><h2>Coordinates and matrices<a class="headerlink" href="#coordinates-and-matrices" title="Permalink to this headline">¶</a></h2>
<p>Coordinates are represented by two classes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Position</span></code> for coordinates in Angstroms (orthogonal coordinates),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Fractional</span></code> for coordinates relative to the unit cell
(fractional coordinates).</p></li>
</ul>
<p>Both <code class="docutils literal notranslate"><span class="pre">Position</span></code> and <code class="docutils literal notranslate"><span class="pre">Fractional</span></code> are derived from <code class="docutils literal notranslate"><span class="pre">Vec3</span></code>,
which has three numeric properties: <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Vec3</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="mf">5.6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">v</span><span class="o">.</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># it can also be indexed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">-3.4</span>
</pre></div>
</div>
<p>The only reason to have separate types is to prevent functions that
expect fractional coordinates from accepting orthogonal ones, and vice versa.
In C++ these types are defined in <code class="docutils literal notranslate"><span class="pre">gemmi/math.hpp</span></code>.</p>
<p>If you have points in space you may want to calculate distances, angles
and dihedral angles:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">degrees</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Position</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Position</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p3</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Position</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p4</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Position</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">degrees</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">calculate_angle</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">))</span>
<span class="go">45.00000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">degrees</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">calculate_dihedral</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">))</span>
<span class="go">90.0</span>
</pre></div>
</div>
<p>Additionally, in C++ you have other functions.
See headers <code class="docutils literal notranslate"><span class="pre">gemmi/math.hpp</span></code> and <code class="docutils literal notranslate"><span class="pre">gemmi/calculate.hpp</span></code>.</p>
<hr class="docutils" />
<p id="transform">Working with macromolecular coordinates involves 3D transformations,
such as crystallographic and non-crystallographic symmetry operations,
and fractionalization and orthogonalization of coordinates.
This requires a tiny bit of linear algebra.</p>
<p>3D transformations tend to be represented either by a 4x4 matrix,
or by a 3x3 matrix and a translation vector. Gemmi uses the latter.
Transformations are represented by the <code class="docutils literal notranslate"><span class="pre">Transform</span></code> class
that has two member variables:
<code class="docutils literal notranslate"><span class="pre">mat</span></code> (of type <code class="docutils literal notranslate"><span class="pre">Mat33</span></code>) and <code class="docutils literal notranslate"><span class="pre">vec</span></code> (of type <code class="docutils literal notranslate"><span class="pre">Vec3</span></code>, which was
introduced above).</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tr</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Transform</span><span class="p">()</span>  <span class="c1"># identity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr</span><span class="o">.</span><span class="n">mat</span>
<span class="go">&lt;gemmi.Mat33 [1, 0, 0]</span>
<span class="go">             [0, 1, 0]</span>
<span class="go">             [0, 0, 1]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr</span><span class="o">.</span><span class="n">vec</span>
<span class="go">&lt;gemmi.Vec3(0, 0, 0)&gt;</span>
</pre></div>
</div>
<p>Both <code class="docutils literal notranslate"><span class="pre">Vec3</span></code> and <code class="docutils literal notranslate"><span class="pre">Mat33</span></code> can be converted to and from Python’s list:
In case of <code class="docutils literal notranslate"><span class="pre">Mat33</span></code> it is a nested list:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tr</span><span class="o">.</span><span class="n">vec</span><span class="o">.</span><span class="n">fromlist</span><span class="p">([</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr</span><span class="o">.</span><span class="n">vec</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[3.0, 4.5, 5.0]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># nested listed for Mat33</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">fromlist</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr</span><span class="o">.</span><span class="n">mat</span>
<span class="go">&lt;gemmi.Mat33 [1, 0, 0]</span>
<span class="go">             [0, 1, -5]</span>
<span class="go">             [0, 0, 1]&gt;</span>
</pre></div>
</div>
<p>Here is an example that shows a few other properties:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># get NCS transformation from an example pdb file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ncs_op</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1lzh.pdb.gz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ncs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">ncs_op</span><span class="p">)</span>
<span class="go">&lt;class &#39;gemmi.Transform&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ncs_op</span><span class="o">.</span><span class="n">mat</span>
<span class="go">&lt;gemmi.Mat33 [0.97571, -0.2076, 0.06998]</span>
<span class="go">             [0.2156, 0.96659, -0.13867]</span>
<span class="go">             [-0.03885, 0.15039, 0.98786]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span>
<span class="go">1.000003887799667</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ncs_op</span><span class="o">.</span><span class="n">vec</span>
<span class="go">&lt;gemmi.Vec3(-14.1959, 0.72997, -30.5229)&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># is the 3x3 matrix above orthogonal?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span> <span class="o">=</span> <span class="n">ncs_op</span><span class="o">.</span><span class="n">mat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">identity</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Mat33</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="n">identity</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ncs_op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">Vec3</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">))</span>
<span class="go">&lt;gemmi.Vec3(1.8895, 28.4929, 12.7262)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ncs_op</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">&lt;gemmi.Vec3(20, 30, 40)&gt;</span>
</pre></div>
</div>
<p>To avoid mixing of orthogonal and fractional coordinates
Gemmi also has <code class="docutils literal notranslate"><span class="pre">FTransform</span></code>, which is like <code class="docutils literal notranslate"><span class="pre">Transform</span></code>,
but can be applied only to <code class="docutils literal notranslate"><span class="pre">Fractional</span></code> coordinates.</p>
<hr class="docutils" />
<p>We have special classes for symmetric 3x3 matrices: SMat33f and SMat33d
(for 32- and 64-bit floating point numbers, respectively).
These classes are used primarily for anisotropic ADP tensors;
their member variables are named <code class="docutils literal notranslate"><span class="pre">u11</span></code>, <code class="docutils literal notranslate"><span class="pre">u22</span></code>, <code class="docutils literal notranslate"><span class="pre">u33</span></code>,
<code class="docutils literal notranslate"><span class="pre">u12</span></code>, <code class="docutils literal notranslate"><span class="pre">u13</span></code> and <code class="docutils literal notranslate"><span class="pre">u23</span></code>. SMat33 classes provide a few methods,
including calculations of eigenvalues and eigenvectors.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aniso</span> <span class="o">=</span> <span class="n">perovskite</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">aniso</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aniso</span><span class="o">.</span><span class="n">u11</span>
<span class="go">0.10300000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aniso</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
<span class="go">0.41500000000000004</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aniso</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span>
<span class="go">0.002506608000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aniso</span><span class="o">.</span><span class="n">calculate_eigenvalues</span><span class="p">()</span>
<span class="go">[0.10300000000000001, 0.15600000000000003, 0.15600000000000003]</span>
</pre></div>
</div>
<p>In C++ all these types are defined in <code class="docutils literal notranslate"><span class="pre">gemmi/math.hpp</span></code>.</p>
</div>
<div class="section" id="unit-cell">
<span id="unitcell"></span><h2>Unit Cell<a class="headerlink" href="#unit-cell" title="Permalink to this headline">¶</a></h2>
<p>When working with a structural model in a crystal we need to know
the unit cell. In particular, we need to be able to switch between
orthogonal and fractional coordinates.
Here are the most important properties and methods of the <code class="docutils literal notranslate"><span class="pre">UnitCell</span></code> class:</p>
<p><strong>C++</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/unitcell.hpp&gt;</span><span class="cp"></span>

<span class="c1">// UnitCell has:</span>
<span class="c1">// * directly set properties a, b, c, alpha, beta, gamma,</span>
<span class="c1">// * calculated properties such as ar (a*), br (b*), ..., volume,</span>
<span class="c1">// * fractionalization and orthogonalization matrices,</span>
<span class="c1">// * a list of images (symmetry or NCS mates) that is set externally</span>
<span class="c1">//   when reading a file.</span>
<span class="c1">// * and a few functions such as orthogonalize(), fractionalize(),</span>
<span class="c1">//   is_special_position(), find_nearest_image().</span>

<span class="n">gemmi</span><span class="o">::</span><span class="n">UnitCell</span> <span class="n">cell</span><span class="p">(</span><span class="mf">25.14</span><span class="p">,</span> <span class="mf">39.50</span><span class="p">,</span> <span class="mf">45.07</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">);</span>
<span class="n">gemmi</span><span class="o">::</span><span class="n">Position</span> <span class="n">p</span> <span class="o">=</span> <span class="n">cell</span><span class="p">.</span><span class="n">orthogonalize</span><span class="p">(</span><span class="n">gemmi</span><span class="o">::</span><span class="n">Fractional</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">));</span>
</pre></div>
</div>
<p><strong>Python</strong></p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">UnitCell</span><span class="p">(</span><span class="mf">25.14</span><span class="p">,</span> <span class="mf">39.50</span><span class="p">,</span> <span class="mf">45.07</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span>
<span class="go">&lt;gemmi.UnitCell(25.14, 39.5, 45.07, 90, 90, 90)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">c</span>
<span class="go">(25.14, 39.5, 45.07)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">gamma</span>
<span class="go">(90.0, 90.0, 90.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">volume</span>
<span class="go">44755.8621</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">fractionalize</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">Position</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="go">&lt;gemmi.Fractional(0.397772, 0.253165, 0.221877)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">orthogonalize</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">Fractional</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">&lt;gemmi.Position(12.57, 19.75, 22.535)&gt;</span>
</pre></div>
</div>
<p>The UnitCell object can also store a list of symmetry transformations.
This list is populated automatically when reading a coordinate file.
It contains crystallographic symmetry operations. In rare cases
when the file defines strict NCS operarations that are not “given”
(MTRIX record in the PDB format or _struct_ncs_oper in mmCIF)
the list contains also the NCS operations.
With this list we can use:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">UnitCell::volume_per_image()</span> <span class="pre">-&gt;</span> <span class="pre">double</span></code> – returns <code class="docutils literal notranslate"><span class="pre">UnitCell::volume</span></code>
divided by the number of the molecule images in the unit cell,</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1pfe.cif.gz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">spacegroup_hm</span>
<span class="go">&#39;P 63 2 2&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">volume_per_image</span><span class="p">()</span>
<span class="go">12.0</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">UnitCell::is_special_position(const</span> <span class="pre">Position&amp;</span> <span class="pre">pos,</span> <span class="pre">double</span> <span class="pre">max_dist=0.8)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code> –
returns the number of nearby symmetry mates of an atom.
Non-zero only for atoms on special positions.
For example, returns 3 for an atom on 4-fold symmetry axis.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># chloride ion in 1PFE is significantly off the special position</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cl</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sole_residue</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">SeqId</span><span class="p">(</span><span class="s1">&#39;20&#39;</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cl</span>
<span class="go">&lt;gemmi.Atom CL at (-0.3, 23.0, -19.6)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">cl</span><span class="o">.</span><span class="n">occ</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">is_special_position</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">is_special_position</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">is_special_position</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">UnitCell::find_nearest_image(const</span> <span class="pre">Position&amp;</span> <span class="pre">ref,</span> <span class="pre">const</span> <span class="pre">Position&amp;</span> <span class="pre">pos,</span> <span class="pre">Asu</span> <span class="pre">asu)</span> <span class="pre">-&gt;</span> <span class="pre">SymImage</span></code> –
with the last argument set to <code class="docutils literal notranslate"><span class="pre">Asu::Any</span></code>,
it returns the symmetric image of <code class="docutils literal notranslate"><span class="pre">pos</span></code> that is nearest to <code class="docutils literal notranslate"><span class="pre">ref</span></code>.
The last argument can also be set to <code class="docutils literal notranslate"><span class="pre">Asu::Same</span></code> or <code class="docutils literal notranslate"><span class="pre">Asu::Different</span></code>.</p></li>
</ul>
<p>In the reciprocal space, the unit cell can be used to determine interplanar
spacing <em>d</em><sub>hkl</sub> (the resolution corresponding to reflection):</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">calculate_d</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">39.5</span>
</pre></div>
</div>
<p>Computationally, <em>d</em> is calculated from 1/<em>d</em><sup>2</sup>, so if you
need the latter you can calculate it directly:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">calculate_1_d2</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="go">0.20240687828293985</span>
</pre></div>
</div>
</div>
<div class="section" id="reading-coordinate-files">
<h2>Reading coordinate files<a class="headerlink" href="#reading-coordinate-files" title="Permalink to this headline">¶</a></h2>
<p>Gemmi support the following coordinate file formats:</p>
<blockquote>
<div><ul class="simple">
<li><p>mmCIF (PDBx/mmCIF),</p></li>
<li><p>PDB (with popular extensions),</p></li>
<li><p>mmJSON,</p></li>
<li><p>a binary format (MMTF, binary CIF, or own format) is to be considered.</p></li>
</ul>
</div></blockquote>
<p>In this section we show how to read a coordinate file in Gemmi.
In the next sections we will go into details of the individual formats.
Finally, we will show what can be done with a structural model.</p>
<div class="section" id="c">
<h3>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h3>
<p>All the macromolecular coordinate files supported by Gemmi can be opened
using:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Structure</span> <span class="nf">read_structure_file</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">CoorFormat</span> <span class="n">format</span><span class="o">=</span><span class="n">CoorFormat</span><span class="o">::</span><span class="n">Unknown</span><span class="p">)</span>

<span class="c1">// where CoorFormat is defined as</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">CoorFormat</span> <span class="p">{</span> <span class="n">Unknown</span><span class="p">,</span> <span class="n">Pdb</span><span class="p">,</span> <span class="n">Mmcif</span><span class="p">,</span> <span class="n">Mmjson</span> <span class="p">};</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/mmread.hpp&gt;</span><span class="cp"></span>
<span class="c1">// ...</span>
<span class="n">gemmi</span><span class="o">::</span><span class="n">Structure</span> <span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">read_structure_file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;This file has &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">models</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; models.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>In this example the file format is not specified and is determined from
the file extension.</p>
<p><code class="docutils literal notranslate"><span class="pre">gemmi::Structure</span></code> is defined in <code class="docutils literal notranslate"><span class="pre">gemmi/model.hpp</span></code> and
it will be documented <a class="reference internal" href="#mcra"><span class="std std-ref">later on</span></a>.</p>
<p>Gemmi also has a templated function <code class="docutils literal notranslate"><span class="pre">read_structure</span></code> that you can use
to customize how you provide the data (bytes) to the parsers.
This function is used to uncompress gzipped files on the fly:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/mmread.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/gz.hpp&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">read_structure</span><span class="p">(</span><span class="n">gemmi</span><span class="o">::</span><span class="n">MaybeGzipped</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;This file has &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">models</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; models.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Oops. &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you include the <code class="file docutils literal notranslate"><span class="pre">gz.hpp</span></code> header (as in the example above)
the resulting program must be linked with the zlib library.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> c++ -std<span class="o">=</span>c++11 -Iinclude example_above.cpp -lz
<span class="gp">$</span> ./a.out 2cco.cif.gz
<span class="go">This file has 20 models.</span>
</pre></div>
</div>
<p>The <code class="file docutils literal notranslate"><span class="pre">gemmi/mmread.hpp</span></code> header includes many other headers
and is relatively slow to compile. For this reason, consider including it in
only one compilation unit (that does not change often).</p>
<p>Alternatively, if you want to support gzipped files,
use function <code class="docutils literal notranslate"><span class="pre">gemmi::read_structure_gz()</span></code> declared in the header
<code class="docutils literal notranslate"><span class="pre">gemmi/gzread.hpp</span></code> and implemented in <code class="docutils literal notranslate"><span class="pre">gemmi/gzread_impl.hpp</span></code>.
The latter header must be included in only one compilation unit.</p>
<p>If you know the format of files that you will read, you may also
use a function specific to this format. For example, the next section
shows how to read just a PDB file (<code class="docutils literal notranslate"><span class="pre">read_pdb_file(path)</span></code>).</p>
</div>
<div class="section" id="python">
<h3>Python<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h3>
<p>Any of the macromolecular coordinate files supported by Gemmi (gzipped
or not) can be opened using:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>  
<span class="go">&lt;gemmi.Structure ...&gt;</span>
</pre></div>
</div>
<p>If the file format is not specified (example above) it is determined from
the file extension. If the extension is not canonical you can specify
the format explicitely:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">gemmi</span><span class="o">.</span><span class="n">CoorFormat</span><span class="o">.</span><span class="n">Pdb</span><span class="p">)</span>  
<span class="go">&lt;gemmi.Structure ...&gt;</span>
</pre></div>
</div>
<p>The file form
<code class="docutils literal notranslate"><span class="pre">gemmi.Structure</span></code> will be documented <a class="reference internal" href="#mcra"><span class="std std-ref">later on</span></a>.</p>
</div>
</div>
<div class="section" id="pdb-format">
<h2>PDB format<a class="headerlink" href="#pdb-format" title="Permalink to this headline">¶</a></h2>
<p>The PDB format evolved between 1970’s and 2012. Nowadays the PDB organization
uses PDBx/mmCIF as the primary format and the legacy PDB format is frozen.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The PDB format  <a class="reference external" href="https://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html">specification</a> aims to describe the format of files
generated by the wwPDB. It does not aim to specify a format that can
be used for data exchange between third-party programs.
Following literally the specification is neither useful nor possible.
For example: the REVDAT record is mandatory, but using it makes sense
only for the entries released by the PDB.
Therefore no software generates files conforming to the specification
except from the wwPDB software (and even this one is not strictly
conforming: it writes <code class="docutils literal notranslate"><span class="pre">1555</span></code> in the LINK record for the identity operator
while the specifications requires leaving these fields blank).</p>
<p>Do not read too much into the specification.</p>
</div>
<p>Gemmi aims to support all flavours of PDB files that are in common use
in the field of macromolecular crystallography. This includes files from
wwPDB as well as files outputted by mainstream software.</p>
<p>In particular, we support the following extensions:</p>
<ul class="simple">
<li><p>two-character chain IDs (columns 21 and 22),</p></li>
<li><p>segment ID (columns 73-76) from PDB v2,</p></li>
<li><p><a class="reference external" href="http://cci.lbl.gov/hybrid_36/">hybrid-36</a> encoding of sequence IDs for sequences longer than 9999
(although we are yet to find an examples for this),</p></li>
<li><p><a class="reference external" href="http://cci.lbl.gov/hybrid_36/">hybrid-36</a> encoding of serial numbers for more than 99,999 atoms.</p></li>
</ul>
<p>Gemmi interprets more PDB records than most of programs and libraries,
but supporting all the records is not a goal.
The records that are interpreted can be converted from/to mmCIF:</p>
<ul class="simple">
<li><p>HEADER</p></li>
<li><p>TITLE</p></li>
<li><p>KEYWDS</p></li>
<li><p>EXPDTA</p></li>
<li><p>NUMMDL</p></li>
<li><p>REMARK 2</p></li>
<li><p>REMARK 3 (read-only, i.e. only in PDB -&gt; mmCIF conversion)</p></li>
<li><p>REMARK 200/230/240 (read-only)</p></li>
<li><p>REMARK 290 (partly-read, but not by default)</p></li>
<li><p>REMARK 300 (read-only)</p></li>
<li><p>REMARK 350</p></li>
<li><p>DBREF/DBREF1/DBREF2</p></li>
<li><p>SEQRES</p></li>
<li><p>HELIX</p></li>
<li><p>SHEET</p></li>
<li><p>SSBOND</p></li>
<li><p>LINK</p></li>
<li><p>CISPEP</p></li>
<li><p>CRYST1</p></li>
<li><p>ORIGXn</p></li>
<li><p>SCALEn</p></li>
<li><p>MTRIXn</p></li>
<li><p>MODEL/ENDMDL</p></li>
<li><p>ATOM/HETATM</p></li>
<li><p>ANISOU</p></li>
<li><p>TER</p></li>
<li><p>END</p></li>
</ul>
<p>Although the PDB format is widely used, some of its features can be easily
overlooked. The rest of this section describes
such features. It is for people who are interested in the details
of the PDB format.
You do not need to read it if you just want to use Gemmi and work with
molecular models.</p>
<hr class="docutils" />
<p>Let us start with the the list of atoms:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HETATM    8  CE  MSE A   1       8.081   3.884  27.398  1.00 35.65           C
ATOM      9  N   GLU A   2       2.464   5.718  24.671  1.00 14.40           N
ATOM     10  CA  GLU A   2       1.798   5.810  23.368  1.00 13.26           C
</pre></div>
</div>
<p>Standard residues of protein, DNA or RNA are marked as ATOM. Solvent,
ligands, metals, carbohydrates and everything else is marked as HETATM.
What about non-standard residues of protein, DNA or RNA?
According to the wwPDB they are HETATM,
but some programs and crystallographers prefer to mark them as ATOM.
It is better to not rely on any of the two conventions.
In particular, removing ligands and solvent cannot be done by
removing all the HETATM records.</p>
<p>The next field after ATOM/HETATM is the serial number of an atom.
The wwPDB spec limits the serial numbers to the range 1–99,999,
but the popular extension
called <a class="reference external" href="http://cci.lbl.gov/hybrid_36/">hybrid-36</a> allows to have more atoms in the file by using
also letters in this field. If you do not need to interpret the CONECT
records the serial number can be simply ignored.</p>
<p>Columns 13-27 describe the atom’s place in the hierarchy.
In the example above they are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1      2
345678901234567

 CE  MSE A   1
 N   GLU A   2
 CA  GLU A   2
</pre></div>
</div>
<p>Here the CE atom is in chain A, in residue MSE with sequence ID 1.</p>
<p>The atom names (columns 13-16) starts with the element name,
and as a rule columns 13-14 contain only the element name.
Therefore Cα and calcium ion, both named CA, are aligned differently:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1      2
345678901234567
 CA  GLU A   2
CA    CA A 101
</pre></div>
</div>
<p>This rule has an exception: when the atom name has four characters
it starts in column 13 even if it has a one-letter element code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HETATM 6495  CAX R58 A 502      17.143 -29.934   7.180  1.00 58.54           C
HETATM 6496 CAX3 R58 A 502      16.438 -31.175   6.663  1.00 57.68           C
</pre></div>
</div>
<p>Columns 23-27 contain a sequence ID. It consists of a number (columns 23-26)
and, optionally, also an insertion code (A-Z) in column 27:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ATOM  11918  CZ  PHE D 100      -6.852  76.356 -23.289  1.00107.94           C
ATOM  11919  N   ARG D 100A     -9.676  74.726 -19.958  1.00105.71           N
...
ATOM  11970  CE  MET D 100H     -8.264  83.348 -19.494  1.00107.93           C
ATOM  11971  N   ASP D 101     -11.329  81.237 -14.804  1.00107.41           N
</pre></div>
</div>
<p>The insertion codes are the opposite of gaps in the numbering;
both are used to make the numbering consistent with a reference sequence
(and for the same reason the sequence number can be negative).</p>
<p>Another fields that is blank for most of the atoms is altloc.
It is a letter marking an alternative conformation
(columns 17, just before the residue name):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HETATM  557  O  AHOH A 301      13.464  41.125   8.469  0.50 20.23           O
HETATM  558  O  BHOH A 301      12.554  42.700   8.853  0.50 26.40           O
</pre></div>
</div>
<p>Handling alternative conformations adds a lot of complexity,
as it will be described later on in this documentation.
These were all tricky things in the atom list.</p>
<p>Now let’s go to matrices. In most of the PDB entries the CRYST1 record
is all that is needed to construct the crystal structure.
But in some PDB files we need to take into account two other records:</p>
<ul class="simple">
<li><p>MTRIX – if marked as not-given it defines operations needed to reconstruct
the asymmetric unit,</p></li>
<li><p>SCALE – provides fractionalization matrix. The format of this entry
is unfortunate: for large unit cells the relative precision of numbers is
too small. So if coordinates are given in standard settings it is better
to calculate the fractionalization matrix from the unit cell dimensions
(i.e. from the CRYST1 record).
But the SCALE record needs to be checked to see if the settings <em>are</em>
the standard ones.</p></li>
</ul>
<div class="section" id="reading">
<h3>Reading<a class="headerlink" href="#reading" title="Permalink to this headline">¶</a></h3>
<p><strong>C++</strong></p>
<p>As described in the previous section, all coordinate files can be read
using the same function calls. Additionally, in C++, you may read a selected
file format to avoid linking with the code you do not use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/pdb.hpp&gt;     // to read</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/gz.hpp&gt;      // to uncompress on the fly</span><span class="cp"></span>

<span class="n">gemmi</span><span class="o">::</span><span class="n">Structure</span> <span class="n">st1</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">read_pdb_file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="c1">// or</span>
<span class="n">gemmi</span><span class="o">::</span><span class="n">Structure</span> <span class="n">st2</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">read_pdb</span><span class="p">(</span><span class="n">gemmi</span><span class="o">::</span><span class="n">MaybeGzipped</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>
</pre></div>
</div>
<p>The content of the file can also be read from a string or from memory:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Structure</span> <span class="nf">read_pdb_string</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
<span class="n">Structure</span> <span class="nf">read_pdb_from_memory</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Python</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gemmi</span>

<span class="c1"># just use interface common for all file formats</span>
<span class="n">structure</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># or a function that reads only pdb files</span>
<span class="n">structure</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_pdb</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># if you have the content of the PDB file in a string:</span>
<span class="n">structure</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_pdb_string</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>Not all the metadata read from a PDB file is directly accessible from Python.
Experimental details, refinement statistics, the secondary structure
information, and many other things can be only read indirectly,
by first putting it into a cif.Block:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/5moo_header.pdb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">make_mmcif_headers</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block</span><span class="o">.</span><span class="n">get_mmcif_category</span><span class="p">(</span><span class="s1">&#39;_diffrn&#39;</span><span class="p">)</span>
<span class="go">{&#39;id&#39;: [&#39;1&#39;, &#39;2&#39;], &#39;crystal_id&#39;: [&#39;1&#39;, &#39;2&#39;], &#39;ambient_temp&#39;: [&#39;295&#39;, &#39;295&#39;]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block</span><span class="o">.</span><span class="n">get_mmcif_category</span><span class="p">(</span><span class="s1">&#39;_diffrn_radiation&#39;</span><span class="p">)</span>
<span class="go">{&#39;diffrn_id&#39;: [&#39;1&#39;, &#39;2&#39;], &#39;pdbx_scattering_type&#39;: [&#39;x-ray&#39;, &#39;neutron&#39;], &#39;pdbx_monochromatic_or_laue_m_l&#39;: [&#39;M&#39;, None], &#39;monochromator&#39;: [None, None]}</span>
</pre></div>
</div>
<p>PDB files are expected to have 80 columns, although trailing spaces are
often not included. Some programs in certain situations produce longer lines,
so Gemmi reads lines up to 120 characters. In some old files from
the <a class="reference external" href="ftp://snapshots.rcsb.org/20050106/">wwPDB snapshots</a>
columns 73-80 contain PDB ID and line number (such as “1ABC 205”).
It confuses the PDB parser and it is not handled automatically – such
files are not in use nowadays. Nevertheless, they can be read by manually
limiting the line length:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">read_pdb</span><span class="p">(</span><span class="s1">&#39;../tests/pdb1gdr.ent&#39;</span><span class="p">,</span> <span class="n">max_line_length</span><span class="o">=</span><span class="mi">72</span><span class="p">)</span>
<span class="go">&lt;gemmi.Structure pdb1gdr.ent with 1 model(s)&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="writing">
<h3>Writing<a class="headerlink" href="#writing" title="Permalink to this headline">¶</a></h3>
<p><strong>C++</strong></p>
<p>Function for writing data from Structure to a pdb file are
in a header <code class="docutils literal notranslate"><span class="pre">gemmi/to_pdb.hpp</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">write_pdb</span><span class="p">(</span><span class="k">const</span> <span class="n">Structure</span><span class="o">&amp;</span> <span class="n">st</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span>
               <span class="n">PdbWriteOptions</span> <span class="n">opt</span><span class="o">=</span><span class="n">PdbWriteOptions</span><span class="p">());</span>
<span class="kt">void</span> <span class="nf">write_minimal_pdb</span><span class="p">(</span><span class="k">const</span> <span class="n">Structure</span><span class="o">&amp;</span> <span class="n">st</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">make_pdb_headers</span><span class="p">(</span><span class="k">const</span> <span class="n">Structure</span><span class="o">&amp;</span> <span class="n">st</span><span class="p">);</span>
</pre></div>
</div>
<p>Internally, these functions use the
<a class="reference external" href="https://github.com/nothings/stb">stb_sprintf</a> library.
And like in stb-style libraries, the implementation of the functions above
is guarded by a macro. In exactly one file you need to add:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define GEMMI_WRITE_IMPLEMENTATION</span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/to_pdb.hpp&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p><strong>Python</strong></p>
<p>To output a file or string in the PDB format use one of the functions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># To write full PDB use (the options are listed below):</span>
<span class="n">structure</span><span class="o">.</span><span class="n">write_pdb</span><span class="p">(</span><span class="n">path</span> <span class="p">[,</span> <span class="n">options</span><span class="p">])</span>

<span class="c1"># To write only CRYST1 and coordinates, use:</span>
<span class="n">structure</span><span class="o">.</span><span class="n">write_minimal_pdb</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># To get the same as a string:</span>
<span class="n">pdb_string</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">make_minimal_pdb</span><span class="p">()</span>

<span class="c1"># To get PDB headers as a string:</span>
<span class="n">header_string</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">make_pdb_headers</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">write_pdb()</span></code> has options to suppress writing of various records,
to avoid assigning a serial number to the TER record,
and to add use non-standard Refmac LINKR record instead of LINK.
Here is the full signature:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">Structure</span><span class="o">.</span><span class="n">write_pdb</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">         &#39;</span><span class="p">))</span>
<span class="go">write_pdb(self: gemmi.Structure,</span>
<span class="go">          path: str,</span>
<span class="go">          seqres_records: bool = True,</span>
<span class="go">          ssbond_records: bool = True,</span>
<span class="go">          link_records: bool = True,</span>
<span class="go">          cispep_records: bool = True,</span>
<span class="go">          ter_records: bool = True,</span>
<span class="go">          numbered_ter: bool = True,</span>
<span class="go">          use_linkr: bool = False) -&gt; None</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pdbx-mmcif-format">
<h2>PDBx/mmCIF format<a class="headerlink" href="#pdbx-mmcif-format" title="Permalink to this headline">¶</a></h2>
<p>The mmCIF format (more formally: PDBx/mmCIF) became the primary format
used by the wwPDB. The format uses the CIF 1.1 syntax with semantics
described by the PDBx/mmCIF DDL2 dictionary.</p>
<p>While this section may clarify a few things, you do not need to read it
to work with mmCIF files.</p>
<p>The main characteristics of the CIF syntax are described in the
<a class="reference internal" href="cif.html#cif-intro"><span class="std std-ref">CIF introduction</span></a>.
Here we focus on things specific to mmCIF:</p>
<ul>
<li><p>PDBx/mmCIF dictionary is clearly inspired by relational databases.
Categories correspond to tables. Data items correspond to columns.
Key data items correspond to primary (or composite) keys in RDBMS.</p>
<p>While a single block in a single file always describes a single PDB entry,
some relations between tables seem to be designed for any number of entries
in one block.
For example, although a file has only one <code class="docutils literal notranslate"><span class="pre">_entry.id</span></code> and
<code class="docutils literal notranslate"><span class="pre">_struct.title</span></code>, the dictionary uses an extra item called
<code class="docutils literal notranslate"><span class="pre">_struct.entry_id</span></code> to match the title with id.
Is it a good practice to check <code class="docutils literal notranslate"><span class="pre">_struct.entry_id</span></code> before reading
<code class="docutils literal notranslate"><span class="pre">_struct.title</span></code>? Probably not, as I have seen files with missing
<code class="docutils literal notranslate"><span class="pre">_struct.entry_id</span></code> but never (yet) with multiple <code class="docutils literal notranslate"><span class="pre">_struct.title</span></code>.</p>
</li>
<li><p>Any category (RDBMS table) can be written as a CIF loop (table).
If such a table would have a single row it can be (and always is in wwPDB)
written as key-value pairs.
So when accessing a value it is safer to use abstraction that hides the
difference between a loop and a key-value pair
(<code class="docutils literal notranslate"><span class="pre">cif::Table</span></code> in Gemmi).</p></li>
<li><p>Arguably, the mmCIF format is harder to parse than the old PDB format.
Using <code class="docutils literal notranslate"><span class="pre">grep</span></code> and <code class="docutils literal notranslate"><span class="pre">awk</span></code> to extract atoms will work only with files
written in a specific layout, usually by a particular software.
It is unfortunate that the wwPDB FAQ encourages it, so one may expect
portability problems when using mmCIF.</p></li>
<li><p>The atoms (<code class="docutils literal notranslate"><span class="pre">_atom_site</span></code>) table has four “author defined alternatives”
(<code class="docutils literal notranslate"><span class="pre">.auth_*</span></code>) that have similar meaning to the “primary” identifiers
(<code class="docutils literal notranslate"><span class="pre">.label_*</span></code>).
Two of them, atom name (<code class="docutils literal notranslate"><span class="pre">atom_id</span></code>) and residue name (<code class="docutils literal notranslate"><span class="pre">comp_id</span></code>)
<a class="reference internal" href="cif.html#auth-label-example"><span class="std std-ref">almost never</span></a> differ.
The other two, chain name (<code class="docutils literal notranslate"><span class="pre">asym_id</span></code>) and sequence number (<code class="docutils literal notranslate"><span class="pre">seq_id</span></code>)
may differ in a confusing way (A,B,C &lt;-&gt; C,A,B).
Which one is presented to the user depends on a program (usually
the author’s version). This may lead to funny situations.</p></li>
<li><p>There is a formal distinction between mmCIF and PDBx/mmCIF
dictionaries (they are controlled by separate committees).
The latter is built upon the former. So we have
the <code class="docutils literal notranslate"><span class="pre">pdbx_</span></code> prefix in otherwise random places, to mark tags
that are not in the vanilla mmCIF.</p></li>
</ul>
<p>Here are example lines from a PDB file (3B9F) with the fields
numbered at the bottom:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ATOM   1033  OE2 GLU H  77      -9.804  19.834 -55.805  1.00 25.54           O
ATOM   1034  N  AARG H  77A     -4.657  24.646 -55.236  0.11 20.46           N
ATOM   1035  N  BARG H  77A     -4.641  24.646 -55.195  0.82 22.07           N
 |       |   |  | |  |  | |       |       |       |      |     |             | |
 1       2   3  4 5  6  7 8       9       10      11     12    13           14 15
</pre></div>
</div>
<p>and the corresponding lines from PDBx/mmCIF v5 (as served by the PDB in 2018):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ATOM   1032 O OE2 . GLU B 2  72  ? -9.804  19.834  -55.805 1.00 25.54 ? 77   GLU H OE2 1
ATOM   1033 N N   A ARG B 2  73  A -4.657  24.646  -55.236 0.11 20.46 ? 77   ARG H N   1
ATOM   1034 N N   B ARG B 2  73  A -4.641  24.646  -55.195 0.82 22.07 ? 77   ARG H N   1
 |       |  | |   |  |  | |   |  |    |       |       |     |    |    |  |    |  | |   |
 1       2 14 N   4  N  N N   N  8    9       10      11    12   13   15 7    5  6 3   N
 |       |  | |   |  label_comp_id    Cartn_x |       |     |    B_iso_or_equiv  | auth_atom_id
 |       id | |   label_alt_id|  pdbx_PDB_ins_code    |     occupancy |  |    |  auth_asym_id
 group_PDB  | label_atom_id   label_seq_id    |       Cartn_z         |  |    auth_comp_id
            type_symbol | label_entity_id     Cartn_y                 |  auth_seq_id   pdbx_PDB_model_num
                        label_asym_id                                 pdbx_formal_charge
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">N</span></code> marks columns not present in the PDB file.
Numbers in column 2 differ because in the PDB file the TER record (that mark
end of a polymer) is also assigned a number.</p>
<p><code class="docutils literal notranslate"><span class="pre">auth_seq_id</span></code> used to be the full author’s sequence ID,
but currently in the wwPDB entries it is only the sequence number;
the insertion code is stored in a separate column (<code class="docutils literal notranslate"><span class="pre">pdbx_PDB_ins_code</span></code>).
Confusingly, <code class="docutils literal notranslate"><span class="pre">pdbx_PDB_ins_code</span></code> is placed next to <code class="docutils literal notranslate"><span class="pre">label_seq_id</span></code>
not <code class="docutils literal notranslate"><span class="pre">auth_seq_id</span></code>
(<code class="docutils literal notranslate"><span class="pre">label_seq_id</span></code> is always a positive number and has nothing to do
with the insertion code).</p>
<p>As mentioned above, the mmCIF format has two sets of names/numbers:
<em>label</em> and <em>auth</em> (for “author”).
<code class="docutils literal notranslate"><span class="pre">label_atom_id</span></code> and <code class="docutils literal notranslate"><span class="pre">auth_atom_id</span></code> almost never differ, the same
about <code class="docutils literal notranslate"><span class="pre">label_comp_id</span></code> and <code class="docutils literal notranslate"><span class="pre">auth_comp_id</span></code>.
Gemmi uses author-defined atom and component IDs if they are present,
otherwise it uses <em>label</em> ones.</p>
<p>On the other hand, chain names (<code class="docutils literal notranslate"><span class="pre">asym_id</span></code>) and sequence numbers often
differ and in the user interface it is better to use the author-defined
names, for consistency with the PDB format and with the literature.</p>
<p id="subchain">While this is not guaranteed by the specification, in all PDB entries
each <code class="docutils literal notranslate"><span class="pre">auth_asym_id</span></code> “chain” is split into one or more <code class="docutils literal notranslate"><span class="pre">label_asym_id</span></code>
“chains”; let us call them <em>subchains</em>.
The polymer (residues before the TER record in the PDB format) goes into
one subchain; all the other (non-polymer) residues are put into
single-residue subchains;
except the waters, which are all put into one subchain.
Currently, wwPDB treats non-linear polymers (such as sugars) as non-polymers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Having two sets of identifiers in parallel is not a good idea.
Making them look the same so they can be confused is a bad design.</p>
<p>Additionally, the label_* identifiers are not unique: waters have null
<code class="docutils literal notranslate"><span class="pre">label_seq_id</span></code> and therefore all waters in one chain have the same
identifier. If a water atom is referenced in another table (_struct_conn
or _struct_site_gen) the label_* identifier is ambiguous,
so it is necessary to use the auth_* identifier anyway.</p>
</div>
<p>This all is quite confusing and lacks a proper documentation.
So once again, now in a color-coded version:</p>
<div class="highlight"><pre style="color:#444">
ATOM   <b>1032</b> O <span style="color:#d50">OE2 <span style="background-color:#ace">.</span> GLU B</span> 2  <span style="color:#d50">72</span>  <span style="background-color:#ace">?</span> -9.804  19.834  -55.805 1.00 25.54 ? <span style="background-color:#ace">77   GLU H OE2</span> 1
ATOM   <b>1033</b> N <span style="color:#d50">N   <span style="background-color:#ace">A</span> ARG B</span> 2  <span style="color:#d50">73</span>  <span style="background-color:#ace">A</span> -4.657  24.646  -55.236 0.11 20.46 ? <span style="background-color:#ace">77   ARG H N  </span> 1
ATOM   <b>1034</b> N <span style="color:#d50">N   <span style="background-color:#ace">B</span> ARG B</span> 2  <span style="color:#d50">73</span>  <span style="background-color:#ace">A</span> -4.641  24.646  -55.195 0.82 22.07 ? <span style="background-color:#ace">77   ARG H N  </span> 1
</pre></div><p>and a couple lines from another file (6any):</p>
<div class="highlight"><pre style="color:#444">
ATOM   <b>1   </b> N <span style="color:#d50">N   <span style="background-color:#ace">.</span> PHE A</span> 1 <span style="color:#d50">1  </span> <span style="background-color:#ace">?</span> 21.855 30.874 0.439  1.00 29.16 ? <span style="background-color:#ace">17  PHE A N  </span> 1
ATOM   <b>2   </b> C <span style="color:#d50">CA  <span style="background-color:#ace">.</span> PHE A</span> 1 <span style="color:#d50">1  </span> <span style="background-color:#ace">?</span> 20.634 31.728 0.668  1.00 26.60 ? <span style="background-color:#ace">17  PHE A CA </span> 1

ATOM   <b>1630</b> C <span style="color:#d50">CD2 <span style="background-color:#ace">.</span> LEU A</span> 1 <span style="color:#d50">206</span> <span style="background-color:#ace">?</span> 23.900 18.559 1.006  1.00 16.97 ? <span style="background-color:#ace">222 LEU A CD2</span> 1
HETATM <b>1631</b> C <span style="color:#d50">C1  <span style="background-color:#ace">.</span> NAG B</span> 2 <span style="color:#d50">.  </span> <span style="background-color:#ace">?</span> 5.126  22.623 37.322 1.00 30.00 ? <span style="background-color:#ace">301 NAG A C1 </span> 1
HETATM <b>1632</b> C <span style="color:#d50">C2  <span style="background-color:#ace">.</span> NAG B</span> 2 <span style="color:#d50">.  </span> <span style="background-color:#ace">?</span> 5.434  21.608 38.417 1.00 30.00 ? <span style="background-color:#ace">301 NAG A C2 </span> 1

HETATM <b>1709</b> O <span style="color:#d50">O   <span style="background-color:#ace">.</span> HOH I</span> 6 <span style="color:#d50">.  </span> <span style="background-color:#ace">?</span> -4.171 14.902 2.395  1.00 33.96 ? <span style="background-color:#ace">401 HOH A O  </span> 1
HETATM <b>1710</b> O <span style="color:#d50">O   <span style="background-color:#ace">.</span> HOH I</span> 6 <span style="color:#d50">.  </span> <span style="background-color:#ace">?</span> 9.162  43.925 8.545  1.00 21.30 ? <span style="background-color:#ace">402 HOH A O  </span> 1
</pre></div><p>Each atom site has three independent identifiers:</p>
<ol class="arabic simple">
<li><p>The number in bold is a short and simple one (it does not need to
be a number according to the mmCIF spec).</p></li>
<li><p>The hierarchical identifier from the PDB format (<span class="blue-bg">blue</span> background)
is what people usually use. Unfortunately, the arbitrary ordering
of columns makes it harder to interpret.</p></li>
<li><p>The new mmCIF identifier (<span class="orange-fg">orange</span>) is confusingly similar to 2,
but it cannot uniquely identify water atoms,
so it cannot be used in every context.</p></li>
</ol>
<p>How other tables in the mmCIF file refer to atom sites?
Some use both 2 and 3 (e.g. _struct_conn), some use only 2 (e.g. _struct_site),
and _atom_site_anisotrop uses all 1, 2 and 3.</p>
<div class="section" id="id2">
<h3>Reading<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>As a reminder, you may use the functions common for all file formats
(such as <code class="docutils literal notranslate"><span class="pre">read_structure_gz()</span></code>) to read a structure.</p>
<p>But you may also use two functions that give you more control.
These functions correspond to two stages
of reading mmCIF files in Gemmi:
file → <code class="docutils literal notranslate"><span class="pre">cif::Document</span></code> → <code class="docutils literal notranslate"><span class="pre">Structure</span></code>.</p>
<p><strong>C++</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/cif.hpp&gt;       // file -&gt; cif::Document</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/gz.hpp&gt;        // uncompressing on the fly</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/mmcif.hpp&gt;     // cif::Document -&gt; Structure</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">cif</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">cif</span><span class="p">;</span>

<span class="n">cif</span><span class="o">::</span><span class="n">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">cif</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">gemmi</span><span class="o">::</span><span class="n">MaybeGzipped</span><span class="p">(</span><span class="n">mmcif_file</span><span class="p">));</span>
<span class="n">gemmi</span><span class="o">::</span><span class="n">Structure</span> <span class="n">structure</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">make_structure</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cif::Document</span></code> can be additionally used to access meta-data,
such as the details of the experiment or software used for data processing.
The examples are provided in the <a class="reference internal" href="cif.html#cif-examples"><span class="std std-ref">CIF parser</span></a> section.</p>
<p><strong>Python</strong></p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cif_block</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">cif</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mmcif_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">make_structure_from_block</span><span class="p">(</span><span class="n">cif_block</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cif_block</span></code> can be additionally used to access meta-data.</p>
</div>
<div class="section" id="id3">
<h3>Writing<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Writing is also in two stages: first a <code class="docutils literal notranslate"><span class="pre">cif::Document</span></code> is created
and then it is written to disk.</p>
<p><strong>C++</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/to_mmcif.hpp&gt;  // Structure -&gt; cif::Document</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/to_cif.hpp&gt;    // cif::Document -&gt; file</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">os</span><span class="p">(</span><span class="s">&quot;new.cif&quot;</span><span class="p">);</span>
<span class="n">gemmi</span><span class="o">::</span><span class="n">write_cif_to_file</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">make_mmcif_document</span><span class="p">(</span><span class="n">structure</span><span class="p">));</span>
</pre></div>
</div>
<p><strong>Python</strong></p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span><span class="o">.</span><span class="n">make_mmcif_document</span><span class="p">()</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="s1">&#39;new.cif&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="mmjson-format">
<h2>mmJSON format<a class="headerlink" href="#mmjson-format" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="https://pdbj.org/help/mmjson?lang=en">mmJSON</a> format is a JSON representation of the mmCIF data.
This format can be easily parsed with any JSON parser (Gemmi uses
<a class="reference external" href="https://github.com/chadaustin/sajson">sajson</a>).
It is a good alternative to PDBML – easier to parse and smaller.</p>
<p>Files in this format are available from PDBj using REST API:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>curl -o 5MOO.json.gz &#39;https://pdbj.org/rest/downloadPDBfile?id=5MOO&amp;format=mmjson-all&#39;
</pre></div>
</div>
<p>as well as <a class="reference external" href="https://pdbj.org/help/mmjson?lang=en">ftp/rsync</a>.</p>
<p>Gemmi reads mmJSON files into <code class="docutils literal notranslate"><span class="pre">cif::Document</span></code>,
as it does with mmCIF files.</p>
<div class="section" id="id5">
<h3>Reading<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p><strong>C++</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/json.hpp&gt;     // JSON -&gt; cif::Document</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/mmcif.hpp&gt;    // cif::Document -&gt; Structure</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gemmi/gz.hpp&gt;       // to uncompress on the fly</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">cif</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">cif</span><span class="p">;</span>

<span class="n">cif</span><span class="o">::</span><span class="n">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">cif</span><span class="o">::</span><span class="n">read_mmjson_file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="c1">// or, to handle gzipped files:</span>
<span class="n">cif</span><span class="o">::</span><span class="n">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">cif</span><span class="o">::</span><span class="n">read_mmjson</span><span class="p">(</span><span class="n">gemmi</span><span class="o">::</span><span class="n">MaybeGzipped</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>
<span class="c1">// and then:</span>
<span class="n">gemmi</span><span class="o">::</span><span class="n">Structure</span> <span class="n">structure</span> <span class="o">=</span>  <span class="n">gemmi</span><span class="o">::</span><span class="n">make_structure</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Python</strong></p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># just use interface common for all file formats</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="n">mmjson_path</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but you can do it in two steps if you wish</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cif_block</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">cif</span><span class="o">.</span><span class="n">read_mmjson</span><span class="p">(</span><span class="n">mmjson_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">make_structure_from_block</span><span class="p">(</span><span class="n">cif_block</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>Writing<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p><strong>C++</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/to_json.hpp&gt;  // for write_mmjson_to_stream</span><span class="cp"></span>

<span class="c1">// cif::Document doc = gemmi::make_mmcif_document(structure);</span>
<span class="n">gemmi</span><span class="o">::</span><span class="n">write_mmjson_to_stream</span><span class="p">(</span><span class="n">ostream</span><span class="p">,</span> <span class="n">doc</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Python</strong></p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Structure -&gt; cif.Document -&gt; mmJSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_str</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">make_mmcif_document</span><span class="p">()</span><span class="o">.</span><span class="n">as_json</span><span class="p">(</span><span class="n">mmjson</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="hierarchy">
<span id="mcra"></span><h2>Hierarchy<a class="headerlink" href="#hierarchy" title="Permalink to this headline">¶</a></h2>
<p>The most useful representation for working with macromolecular models
is a hierarchy of objects.
To a first approximation all macromolecular libraries present the same
hierarchy: model - chain - residue - atom.</p>
<div class="section" id="naming">
<h3>Naming<a class="headerlink" href="#naming" title="Permalink to this headline">¶</a></h3>
<p>While <em>chain</em> and <em>residue</em> are not good names when referring to
ligands and waters, we use this nomenclature as it is the most popular one.
Some libraries (clipper) call it polymer - monomer - atom.
PDBx/mmCIF uses more general (but not so obvious) terms:
<em>entity</em> and <em>struct_asym</em> (structural component in asymetric unit)
instead of chain,
and <em>chem_comp</em> (chemical component) for residue/monomer.</p>
</div>
<div class="section" id="alternative-conformations">
<span id="altconf"></span><h3>Alternative conformations<a class="headerlink" href="#alternative-conformations" title="Permalink to this headline">¶</a></h3>
<p>Apart from the naming, the biggest difference between libraries is
how the disorder is presented. The main options are:</p>
<ul class="simple">
<li><p>group together atoms from the same conformer</p></li>
<li><p>group together alternative locations of the same atom
(cctbx.iotbx has residue-groups and atom-groups)</p></li>
<li><p>leave it to the user (e.g. mmdb and clipper).</p></li>
</ul>
<p>Handling alternative conformations adds significant complexity.
<a class="reference external" href="https://cci.lbl.gov/cctbx_docs/iotbx/iotbx.pdb.html">Reportedly</a>,
“about 90% of the development time invested into iotbx.pdb was in some form
related to alternative conformations”.</p>
<p>Gemmi exposes the <em>altloc</em> field to the user (like mmdb).
On top of it it offers utilities that make working with conformers
easier:</p>
<ul class="simple">
<li><p>functions that ignore all but the main conformation (inspired by BioPython),</p></li>
<li><p>and lightweight proxy objects ResidueGroup and AtomGroup that group
alternative conformers (inspired by iotbx).</p></li>
</ul>
</div>
<div class="section" id="discontinuous-chains">
<h3>Discontinuous chains<a class="headerlink" href="#discontinuous-chains" title="Permalink to this headline">¶</a></h3>
<p>The usual order of atoms in a file is</p>
<ul class="simple">
<li><p>either by chain (A-polymer, A-ligands, A-waters, B-polymer,
B-ligands, B-waters)</p></li>
<li><p>or by chain parts (A-polymer, B-polymer, A-ligands, B-ligands,
A-waters, B-waters).</p></li>
</ul>
<p>In the latter case (example: 100D), chain parts with the same name
are either merged automatically (MMDB, BioPython)
or left as separate chains (iotbx).</p>
<p>In gemmi we support both ways. Since merging is easier than splitting,
the chains are first read separately and after reading the file
the user can call <code class="docutils literal notranslate"><span class="pre">Structure::merge_chain_parts()</span></code>.</p>
<p>In the Python interface merging is also controlled
by second argument to the <code class="docutils literal notranslate"><span class="pre">gemmi.read_structure()</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">read_structure</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">merge_chain_parts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Structure</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<span id="met-mse-example"></span><h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>Next sections document each level of the hierarchy.
But first a simple example.
The code below iterates over all the hierarchy levels
and mutates methionine residues (MET) to selenomethionine (MSE).</p>
<p><strong>C++</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gemmi/model.hpp&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">met_to_mse</span><span class="p">(</span><span class="n">gemmi</span><span class="o">::</span><span class="n">Structure</span><span class="o">&amp;</span> <span class="n">st</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">gemmi</span><span class="o">::</span><span class="n">Model</span><span class="o">&amp;</span> <span class="nl">model</span> <span class="p">:</span> <span class="n">st</span><span class="p">.</span><span class="n">models</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">gemmi</span><span class="o">::</span><span class="n">Chain</span><span class="o">&amp;</span> <span class="nl">chain</span> <span class="p">:</span> <span class="n">model</span><span class="p">.</span><span class="n">chains</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">gemmi</span><span class="o">::</span><span class="n">Residue</span><span class="o">&amp;</span> <span class="nl">res</span> <span class="p">:</span> <span class="n">chain</span><span class="p">.</span><span class="n">residues</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;MET&quot;</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">res</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;MSE&quot;</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">gemmi</span><span class="o">::</span><span class="n">Atom</span><span class="o">&amp;</span> <span class="nl">atom</span> <span class="p">:</span> <span class="n">res</span><span class="p">.</span><span class="n">atoms</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">atom</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;SD&quot;</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">atom</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;SE&quot;</span><span class="p">;</span>
              <span class="n">atom</span><span class="p">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">::</span><span class="n">El</span><span class="o">::</span><span class="n">Se</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Python</strong></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gemmi</span>

<span class="k">def</span> <span class="nf">met_to_mse</span><span class="p">(</span><span class="n">st</span><span class="p">:</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Structure</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;MET&#39;</span><span class="p">:</span>
                    <span class="n">residue</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;MSE&#39;</span>
                    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;SD&#39;</span><span class="p">:</span>
                            <span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;SE&#39;</span>
                            <span class="n">atom</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;Se&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="structure">
<h2>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h2>
<p>The object of type Structure that we get from reading a PDB or mmCIF file
contains one or more models. This is the top level in the hierarchy:
structure - model - chain - residue - atom.</p>
<p>Apart from storing models (usually just a single model)
the <code class="docutils literal notranslate"><span class="pre">Structure</span></code> has the following properties:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> (string) – usually the file basename or PDB code,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cell</span></code> – <a class="reference internal" href="#unitcell"><span class="std std-ref">unit cell</span></a>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spacegroup_hm</span></code> (string) – full space group name in Hermann–Mauguin
notation (usually taken from the coordinate file),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ncs</span></code> (C++ type: <code class="docutils literal notranslate"><span class="pre">vector&lt;NcsOp&gt;</span></code>) – list of NCS operations,
usually taken from the MTRIX record or from the _struct_ncs_oper category,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">resolution</span></code> (C++ type: <code class="docutils literal notranslate"><span class="pre">double</span></code>) – resolution value from REMARK 2 or 3,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">entities</span></code> (C++ type: <code class="docutils literal notranslate"><span class="pre">vector&lt;Entity&gt;</span></code>) – additional information
about <a class="reference internal" href="#subchain"><span class="std std-ref">subchains</span></a>, such as entity type and polymer’s
sequence,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">connections</span></code> (C++ type: <code class="docutils literal notranslate"><span class="pre">vector&lt;Connection&gt;</span></code>) – list of connections
corresponding to the _struct_conn category in mmCIF, or to the pdb records
LINK and SSBOND,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">assemblies</span></code> (C++ type: <code class="docutils literal notranslate"><span class="pre">vector&lt;Assembly&gt;</span></code>) – list of biological
assemblies defined in the REMARK 350 in pdb, or in corresponding mmCIF
categories (_pdbx_struct_assembly, _pdbx_struct_assembly_gen,
_pdbx_struct_assembly_prop and _pdbx_struct_oper_list)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info</span></code> (C++ type: <code class="docutils literal notranslate"><span class="pre">map&lt;string,</span> <span class="pre">string&gt;</span></code>) –
minimal metadata with keys being mmcif tags (_entry.id, _exptl.method, …),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">raw_remarks</span></code> (C++ type: <code class="docutils literal notranslate"><span class="pre">vector&lt;string&gt;</span></code>) – REMARK records
from a PDB file, empty if the input file has different format.</p></li>
</ul>
<p>In Python, the <code class="docutils literal notranslate"><span class="pre">info</span></code> member variable is a dictionary-like object:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="go">_cell.Z_PDB 4</span>
<span class="go">_entry.id 1ORC</span>
<span class="go">_exptl.method X-RAY DIFFRACTION</span>
<span class="go">_pdbx_database_status.recvd_initial_deposition_date 1995-10-30</span>
<span class="go">_struct.title CRO REPRESSOR INSERTION MUTANT K56-[DGEVK]</span>
<span class="go">_struct_keywords.pdbx_keywords GENE REGULATING PROTEIN</span>
<span class="go">_struct_keywords.text GENE REGULATING PROTEIN</span>
</pre></div>
</div>
<p>Gemmi parses many more records from the PDB format, including
REMARK 3 and 200/230. This information is stored in the <code class="docutils literal notranslate"><span class="pre">Metadata</span></code> structure
defined in <code class="docutils literal notranslate"><span class="pre">gemmi/metadata.hpp</span></code>. Currently, it’s not exposed to Python.</p>
<p><code class="docutils literal notranslate"><span class="pre">Structure</span></code> has also a number of methods.
To access or delete a model with known name use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Model</span><span class="o">*</span> <span class="n">Structure</span><span class="o">::</span><span class="n">find_model</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">model_name</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">Structure</span><span class="o">::</span><span class="n">remove_model</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">model_name</span><span class="p">)</span>
</pre></div>
</div>
<p>In Python these functions are wrapped as <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> and <code class="docutils literal notranslate"><span class="pre">__delitem__</span></code>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>        <span class="c1"># by 0-based index</span>
<span class="go">&lt;gemmi.Model 1 with 6 chain(s)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span>      <span class="c1"># by name, which is usually a 1-based index as string</span>
<span class="go">&lt;gemmi.Model 1 with 6 chain(s)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">structure</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>   <span class="c1"># delete all models but the first one</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">structure</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span>  <span class="c1"># delete model &quot;1&quot; (normally, the first one)</span>
</pre></div>
</div>
<p>To add a model to the structure, in C++ use directly methods of:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&gt;</span> <span class="n">Structure</span><span class="o">::</span><span class="n">models</span>
</pre></div>
</div>
<p>and in Python use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Structure</span><span class="o">.</span><span class="n">add_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pos</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>for example,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">structure</span><span class="o">.</span><span class="n">add_model</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="s1">&#39;7&#39;</span><span class="p">))</span>  <span class="c1"># add a new model</span>
<span class="n">structure</span><span class="o">.</span><span class="n">add_model</span><span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>      <span class="c1"># add a copy of model #0</span>
</pre></div>
</div>
<p>After adding or removing models you may call:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span><span class="o">.</span><span class="n">renumber_models</span><span class="p">()</span>
</pre></div>
</div>
<p>which will set model <em>names</em> to sequential numbers (next section
explains why models have names).</p>
<div class="section" id="entity">
<h3>Entity<a class="headerlink" href="#entity" title="Permalink to this headline">¶</a></h3>
<p><em>Entity</em> is a new concept introduced in the mmCIF format.
If the structure is read from a PDB file, we can assign entities
by calling method <code class="docutils literal notranslate"><span class="pre">setup_entities</span></code>.
This method uses a simple heuristic to group residues into
<a class="reference internal" href="#subchain"><span class="std std-ref">subchains</span></a> which are mapped to entities
(this is primarily about finding where the polymer ends;
works best if the TER record is used).
All polymers with identical sequence in the SEQRES record are mapped to
the same entity.</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">setup_entities</span></code> is useful when converting from PDB to mmCIF
(but to just convert files use <a class="reference internal" href="utils.html#convert"><span class="std std-ref">gemmi-convert</span></a>):</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1orc.pdb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">setup_entities</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">make_mmcif_document</span><span class="p">()</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="s1">&#39;out.cif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The Entity object may change in the future.
Here we only show its properties in an example:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">entities</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>  
<span class="go">&lt;gemmi.Entity &#39;A&#39; polymer polypeptide(L) object at 0x...&gt;</span>
<span class="go">&lt;gemmi.Entity &#39;water&#39; water object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span><span class="o">.</span><span class="n">subchains</span>
<span class="go">[&#39;Apoly&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span><span class="o">.</span><span class="n">entity_type</span>
<span class="go">EntityType.Polymer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span><span class="o">.</span><span class="n">polymer_type</span>
<span class="go">PolymerType.PeptideL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span><span class="o">.</span><span class="n">full_sequence</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;MET&#39;, &#39;GLU&#39;, &#39;GLN&#39;, &#39;ARG&#39;, &#39;ILE&#39;]</span>
</pre></div>
</div>
<p>The last property is sequence from the PDB SEQRES record (or mmCIF equivalent).
More details in the <a class="reference internal" href="#sequence"><span class="std std-ref">section about sequence</span></a>.</p>
</div>
<div class="section" id="connection">
<h3>Connection<a class="headerlink" href="#connection" title="Permalink to this headline">¶</a></h3>
<p>The list of connections contains bonds explicitely annotated in the file:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/4oz7.pdb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&lt;gemmi.Connection disulf1  A/CYS 4/SG - A/CYS 10/SG&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&lt;gemmi.Connection covale1  A/22Q 1/C - A/ALA 2/N&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&lt;gemmi.Connection metalc8  B/22Q 1/S - A/CU1 101/CU&gt;</span>
</pre></div>
</div>
<p>You can find connection between two atoms, or check if it exists,
by specifying two <a class="reference internal" href="#atom-address"><span class="std std-ref">atom addresses</span></a>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">addr1</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">AtomAddress</span><span class="p">(</span><span class="n">chain</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">seqid</span><span class="o">=</span><span class="n">gemmi</span><span class="o">.</span><span class="n">SeqId</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">),</span> <span class="n">resname</span><span class="o">=</span><span class="s1">&#39;CYS&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;SG&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr2</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">AtomAddress</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">SeqId</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">),</span> <span class="s1">&#39;CYS&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;SG&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">find_connection</span><span class="p">(</span><span class="n">addr1</span><span class="p">,</span> <span class="n">addr2</span><span class="p">)</span>
<span class="go">&lt;gemmi.Connection disulf2  B/CYS 4/SG - B/CYS 10/SG&gt;</span>
</pre></div>
</div>
<p>Each connection stores:</p>
<ul>
<li><p>type – corresponding to _struct_conn.type in the mmCIF format;
one of enumeration values: Covale, Disulf, Hydrog, MetalC, None;
when reading PDB format the SSBOND record corresponds to Disulf,
LINK records – to Covale or MetalC,</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
<span class="go">ConnectionType.Disulf</span>
</pre></div>
</div>
</li>
<li><p>name – a unique name corresponding to _struct_conn.id in the mmCIF format;
it is auto-generated the connections are read from the PDB format,</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;disulf1&#39;</span>
</pre></div>
</div>
</li>
<li><p>optionally, ID of the link used to restrain this bond during refinement
(_chem_link.id from the CCP4 monomer library),
written as _struct_conn.ccp4_link_id in mmCIF,</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">link_id</span>  <span class="c1"># no link ID -&gt; empty string</span>
<span class="go">&#39;&#39;</span>
</pre></div>
</div>
</li>
<li><p>addresses of two atoms (<code class="docutils literal notranslate"><span class="pre">partner1</span></code> and <code class="docutils literal notranslate"><span class="pre">partner2</span></code>),</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">partner2</span>
<span class="go">&lt;gemmi.AtomAddress A/ALA 2/N&gt;</span>
</pre></div>
</div>
</li>
<li><p>a flag that for connections between different symmetry images,</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">asu</span>
<span class="go">Asu.Same</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">asu</span>
<span class="go">Asu.Different</span>
</pre></div>
</div>
</li>
<li><p>and a distance read from the file.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reported_distance</span>
<span class="go">2.22</span>
</pre></div>
</div>
</li>
</ul>
<p>When the connection is written to a file, the symmetry image and the distance
are recalculated like this:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos1</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">find_cra</span><span class="p">(</span><span class="n">con</span><span class="o">.</span><span class="n">partner1</span><span class="p">)</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">pos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos2</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">find_cra</span><span class="p">(</span><span class="n">con</span><span class="o">.</span><span class="n">partner2</span><span class="p">)</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">pos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">find_nearest_image</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">,</span> <span class="n">con</span><span class="o">.</span><span class="n">asu</span><span class="p">)</span>
<span class="go">&lt;gemmi.SymImage box:[2, 1, 1] sym:5&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">dist</span><span class="p">()</span>
<span class="go">2.22115330402924</span>
</pre></div>
</div>
<p>The vast majority of connections is intramolecular, so usually you get:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">find_nearest_image</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">,</span> <span class="n">con</span><span class="o">.</span><span class="n">asu</span><span class="p">)</span>
<span class="go">&lt;gemmi.SymImage box:[0, 0, 0] sym:0&gt;</span>
</pre></div>
</div>
<p>The section about <a class="reference internal" href="#atom-address"><span class="std std-ref">AtomAddress</span></a>
has an example that shows how to create a new connection.</p>
</div>
<div class="section" id="assembly">
<h3>Assembly<a class="headerlink" href="#assembly" title="Permalink to this headline">¶</a></h3>
<p>Biological assemblies are nicely
<a class="reference external" href="https://pdb101.rcsb.org/learn/guide-to-understanding-pdb-data/biological-assemblies">introduced in PDB-101</a>.
Description of a biological assembly read from a coordinate file
is represented in Gemmi by the <code class="docutils literal notranslate"><span class="pre">Assembly</span></code> class.
It contains a recipe how to construct the assembly from a model.
In the PDB format, REMARK 350 says what operations should be applied
to what chains. In the PDBx/mmCIF format it is similar, but the
<a class="reference internal" href="#subchain"><span class="std std-ref">subchains</span></a> are used instead of chains.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">assembly</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">assemblies</span><span class="p">:</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">assembly</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">assembly</span><span class="o">.</span><span class="n">oligomeric_details</span><span class="p">)</span>
<span class="go">1 MONOMERIC</span>
<span class="go">2 MONOMERIC</span>
</pre></div>
</div>
<p>As always, naming things is hard.
Biological unit may contain a number of copies of one chain.
Each copy needs to be named. Gemmi provides three options:</p>
<ul class="simple">
<li><p>HowToNameCopiedChains.Dup (in C++: HowToNameCopiedChains::Dup) –
simply leaves the original chain name in all copies,</p></li>
<li><p>HowToNameCopiedChains.AddNumber – copies of chain A are named
A1, A2, …, copies of chain B – B1, B2, …, etc,</p></li>
<li><p>HowToNameCopiedChains.Short – unique one-character chain names are used
until exhausted (after 26*2+10=62 chains), then two-character names are used.
This option is appropriate when the output is to be stored in the PDB format.</p></li>
</ul>
<p>Function <code class="docutils literal notranslate"><span class="pre">make_assembly</span></code> takes Model and one of the naming options above,
and returns a new Model that represents the assembly.
In C++ this function is in <code class="docutils literal notranslate"><span class="pre">&lt;gemmi/assembly.hpp&gt;</span></code>.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">assemblies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">make_assembly</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">HowToNameCopiedChains</span><span class="o">.</span><span class="n">AddNumber</span><span class="p">)</span>
<span class="go">&lt;gemmi.Model 1 with 1 chain(s)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">[&lt;gemmi.Chain A1 with 21 res&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">assemblies</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">make_assembly</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">HowToNameCopiedChains</span><span class="o">.</span><span class="n">AddNumber</span><span class="p">)</span>
<span class="go">&lt;gemmi.Model 1 with 1 chain(s)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">[&lt;gemmi.Chain B1 with 26 res&gt;]</span>
</pre></div>
</div>
<p>See also the <code class="docutils literal notranslate"><span class="pre">--assembly</span></code> option in command-line program
<a class="reference internal" href="utils.html#convert"><span class="std std-ref">gemmi-convert</span></a>.</p>
</div>
<div class="section" id="common-operations">
<h3>Common operations<a class="headerlink" href="#common-operations" title="Permalink to this headline">¶</a></h3>
<p>In Python, <code class="docutils literal notranslate"><span class="pre">Structure</span></code> has also methods for more specialized,
but often needed operations:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">remove_alternative_conformations</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">remove_hydrogens</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">remove_waters</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">remove_ligands_and_waters</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">remove_empty_chains</span><span class="p">()</span>
</pre></div>
</div>
<p>In C++ the functions above are provided in <code class="docutils literal notranslate"><span class="pre">gemmi/polyheur.hpp</span></code>.
They are implemented as templated free functions that can be applied
not only to <code class="docutils literal notranslate"><span class="pre">Structure</span></code>, but also to <code class="docutils literal notranslate"><span class="pre">Model</span></code> and <code class="docutils literal notranslate"><span class="pre">Chain</span></code>.</p>
<hr class="docutils" />
<p>Occasionally, you may come across an mmCIF file with chain names longer
than necessary. To store such structure in a PDB format you need to shorten
the chain names first:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">shorten_chain_names</span><span class="p">()</span>
</pre></div>
</div>
<p>In C++ this functions is in <code class="docutils literal notranslate"><span class="pre">gemmi/assembly.hpp</span></code>.</p>
</div>
</div>
<div class="section" id="sequence">
<span id="id7"></span><h2>Sequence<a class="headerlink" href="#sequence" title="Permalink to this headline">¶</a></h2>
<p>In the previous section we introduced sequence with the following example:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span><span class="o">.</span><span class="n">full_sequence</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;MET&#39;, &#39;GLU&#39;, &#39;GLN&#39;, &#39;ARG&#39;, &#39;ILE&#39;]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Entity.full_sequence</span></code> is a list (in C++: <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>) of residue names.
It stores sequence from the SEQRES record (pdb) or
from the _entity_poly_seq category (mmCIF).
The latter can contain microheterogeneity (point mutation).
In such case, the residue names at the same point
in sequence are separated by commas:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1pfe.cif.gz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_entity</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">full_sequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span>
<span class="go">[&#39;DSN&#39;, &#39;ALA&#39;, &#39;N2C,NCY&#39;, &#39;MVA&#39;, &#39;DSN&#39;, &#39;ALA&#39;, &#39;NCY,N2C&#39;, &#39;MVA&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#           ^^^^^^^  microheterogeneity     ^^^^^^^</span>
</pre></div>
</div>
<p>To ignore point mutations we can use a helper function <code class="docutils literal notranslate"><span class="pre">Entity::first_mon</span></code>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">gemmi</span><span class="o">.</span><span class="n">Entity</span><span class="o">.</span><span class="n">first_mon</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span>
<span class="go">[&#39;DSN&#39;, &#39;ALA&#39;, &#39;N2C&#39;, &#39;MVA&#39;, &#39;DSN&#39;, &#39;ALA&#39;, &#39;NCY&#39;, &#39;MVA&#39;]</span>
</pre></div>
</div>
<p>An example in the section about Chain shows how to
<a class="reference internal" href="#polymer-b-sequence"><span class="std std-ref">extract corresponding sequence from the model</span></a>.
In general, the sequence in SEQRES and the sequence in model differ, but
in this file they are the same.</p>
<p>To get a sequence as one-letter codes you can use
the <a class="reference internal" href="#find-tabulated-residue"><span class="std std-ref">built-in table</span></a> of popular residues:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">gemmi</span><span class="o">.</span><span class="n">find_tabulated_residue</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span><span class="o">.</span><span class="n">one_letter_code</span> <span class="k">for</span> <span class="n">resname</span> <span class="ow">in</span> <span class="n">_</span><span class="p">]</span>
<span class="go">[&#39;s&#39;, &#39;A&#39;, &#39; &#39;, &#39;v&#39;, &#39;s&#39;, &#39;A&#39;, &#39; &#39;, &#39;v&#39;]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">one_letter_code</span></code> is lowercase for non-standard residues where it denotes
the parent component. If the code is blank, either the parent component is
not known, or the component is not tabulated in Gemmi (i.e. it’s not in the
top 300+ most popular components in the PDB).
To get a FASTA-like string, you could continue the previous line with:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">code</span> <span class="k">if</span> <span class="n">code</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span> <span class="k">else</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">_</span><span class="p">)</span>
<span class="go">&#39;XAXXXAXX&#39;</span>
</pre></div>
</div>
<p>or use:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">one_letter_code</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="go">&#39;XAXXXAXX&#39;</span>
</pre></div>
</div>
<p>To go in the opposite direction, use:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">gemmi</span><span class="o">.</span><span class="n">expand_protein_one_letter</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span> <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">_</span><span class="p">]</span>
<span class="go">[&#39;UNK&#39;, &#39;ALA&#39;, &#39;UNK&#39;, &#39;UNK&#39;, &#39;UNK&#39;, &#39;ALA&#39;, &#39;UNK&#39;, &#39;UNK&#39;]</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">expand_protein_one_letter_string</span><span class="p">(</span><span class="s1">&#39;XAXXXAXX&#39;</span><span class="p">)</span>
<span class="go">[&#39;UNK&#39;, &#39;ALA&#39;, &#39;UNK&#39;, &#39;UNK&#39;, &#39;UNK&#39;, &#39;ALA&#39;, &#39;UNK&#39;, &#39;UNK&#39;]</span>
</pre></div>
</div>
<div class="section" id="molecular-weight">
<h3>Molecular weight<a class="headerlink" href="#molecular-weight" title="Permalink to this headline">¶</a></h3>
<p>Gemmi provides a simple function to calculate molecular weight
from the sequence. It uses the same built-in table of popular residues.
Since in this example we have two rare components that are not tabulated,
we must specify the avarage weight of unknown residue:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">calculate_sequence_weight</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">unknown</span><span class="o">=</span><span class="mf">130.0</span><span class="p">)</span>
<span class="go">910.7184143066406</span>
</pre></div>
</div>
<p>In such case the result is not accurate, but this is not a typical case.</p>
<p>Now we will take a PDB file with standard residues
and calculate the Matthews coefficient:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/5cvz_final.pdb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[&lt;gemmi.Chain A with 141 res&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># we have just a single chain, which makes this example simpler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span><span class="o">.</span><span class="n">get_polymer</span><span class="p">()</span>
<span class="go">&lt;gemmi.ResidueSpan of 0: []&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Not good. The chain parts where not assigned automatically,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># because of the missing TER record in this file. We need to call:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">setup_entities</span><span class="p">()</span>  <span class="c1"># it should sort out chain parts</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span><span class="o">.</span><span class="n">get_polymer</span><span class="p">()</span>
<span class="go">&lt;gemmi.ResidueSpan of 141: [17(ALA) 18(ALA) 19(ALA) ... 157(SER)]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">get_entity_of</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>  
<span class="go">&lt;gemmi.Entity &#39;A&#39; polymer polypeptide(L) object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weight</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">calculate_sequence_weight</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">full_sequence</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Now we can calculate Matthews coefficient</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">volume_per_image</span><span class="p">()</span> <span class="o">/</span> <span class="n">weight</span>
<span class="go">2.7407915442022364</span>
</pre></div>
</div>
<p>We could continue and calculate the solvent content, assuming the protein
density of 1.35 g/cm<sup>3</sup> (the other constants below are the Avogadro
number and Å<sup>3</sup>/cm<sup>3</sup> = 10<sup>-24</sup>):</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">protein_fraction</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.02214e23</span> <span class="o">*</span> <span class="mf">1e-24</span> <span class="o">*</span> <span class="mf">1.35</span> <span class="o">*</span> <span class="n">_</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solvent content: </span><span class="si">{:.1f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">protein_fraction</span><span class="p">)))</span>
<span class="go">Solvent content: 55.1%</span>
</pre></div>
</div>
<p>Gemmi also includes a program that calculates the solvent content:
<a class="reference internal" href="utils.html#gemmi-contents"><span class="std std-ref">gemmi-contents</span></a>.</p>
</div>
<div class="section" id="sequence-alignment">
<span id="id8"></span><h3>Sequence alignment<a class="headerlink" href="#sequence-alignment" title="Permalink to this headline">¶</a></h3>
<p>Gemmi includes a sequence alignment algorithm based on the simplest
function (ksw_gg) from the <a class="reference external" href="https://github.com/lh3/ksw2">ksw2 project</a>
of <a class="reference external" href="https://www.ncbi.nlm.nih.gov/pubmed/29750242">Heng Li</a>.</p>
<p>It is a pairwise, global alignment with substitution matrix (or just
match/mismatch values) and affine gap penalty.
Additionally, in Gemmi the gap openings at selected positions can be made free.</p>
<p>Let say that we want to align residues in the model to the full sequence.
Sometimes, the alignment is ambiguous. If we’d align texts ABBC and ABC,
both A-BC and AB-C would have the same score. In a 3D structure, the position
of gap can be informed by inter-atomic distances.
This information is used automatically in the <code class="docutils literal notranslate"><span class="pre">align_sequence_to_polymer</span></code>
function. Gap positions, determined by a simple heuristic, are passed
to the alignment algorithm as places where the gap opening penalty
is not to be imposed.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_pdb</span><span class="p">(</span><span class="s1">&#39;../tests/pdb1gdr.ent&#39;</span><span class="p">,</span> <span class="n">max_line_length</span><span class="o">=</span><span class="mi">72</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">align_sequence_to_polymer</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">full_sequence</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_polymer</span><span class="p">(),</span>
<span class="gp">... </span>                                         <span class="n">gemmi</span><span class="o">.</span><span class="n">PolymerType</span><span class="o">.</span><span class="n">PeptideL</span><span class="p">)</span>
</pre></div>
</div>
<p>The arguments of this functions are: sequence (a list of residue names),
<a class="reference internal" href="#residuespan"><span class="std std-ref">ResidueSpan</span></a> (a span of residues in a chain),
and the type of chain, which is used to infer gaps.
(The type can be taken from Entity.polymer_type, but in this example
we wanted to keep things simple).</p>
<p>The result provides statistics and methods of summarizing the alignment:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>  
<span class="go">&lt;gemmi.AlignmentResult object at 0x...&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># score calculated according AlignmentScoring explained below</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">score</span>
<span class="go">69</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># number of matching (identical) residues</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">match_count</span>
<span class="go">105</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># identity = match count / length of the shorter sequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">calculate_identity</span><span class="p">()</span>
<span class="go">100.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># identity wrt. the 1st sequence ( = match count / 1st sequence length)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">calculate_identity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">75.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># identity wrt. the 2nd sequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">calculate_identity</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">100.0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># CIGAR = Concise Idiosyncratic Gapped Alignment Report</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">cigar_str</span><span class="p">()</span>
<span class="go">&#39;11M3I23M7I71M25I&#39;</span>
</pre></div>
</div>
<p>To print out the alignment, we can combine function <code class="docutils literal notranslate"><span class="pre">add_gaps</span></code>
and property <code class="docutils literal notranslate"><span class="pre">match_string</span></code>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">add_gaps</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">one_letter_code</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">full_sequence</span><span class="p">),</span> <span class="mi">1</span><span class="p">)[:</span><span class="mi">70</span><span class="p">]</span>
<span class="go">&#39;MRLFGYARVSTSQQSLDIQVRALKDAGVKANRIFTDKASGSSSDRKGLDLLRMKVEEGDVILVKKLDRLG&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">match_string</span><span class="p">[:</span><span class="mi">70</span><span class="p">]</span>
<span class="go">&#39;|||||||||||   |||||||||||||||||||||||       ||||||||||||||||||||||||||&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">add_gaps</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">one_letter_code</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_polymer</span><span class="p">()),</span> <span class="mi">2</span><span class="p">)[:</span><span class="mi">70</span><span class="p">]</span>
<span class="go">&#39;MRLFGYARVST---SLDIQVRALKDAGVKANRIFTDK-------RKGLDLLRMKVEEGDVILVKKLDRLG&#39;</span>
</pre></div>
</div>
<p>or we can use function <code class="docutils literal notranslate"><span class="pre">AlignmentResult.formatted()</span></code>.</p>
<p>We also have a function that aligns two sequences.
We can exercise it by comparing two strings:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">align_string_sequences</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;kitten&#39;</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;sitting&#39;</span><span class="p">),</span> <span class="p">[])</span>
</pre></div>
</div>
<p>The third argument above is a list of free gap openings.
Now we can visualize the match:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="s1">&#39;kitten&#39;</span><span class="p">,</span> <span class="s1">&#39;sitting&#39;</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  
<span class="go">kitten-</span>
<span class="go">.|||.|</span>
<span class="go">sitting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">score</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The alignment and the score is calculate according to AlignmentScoring,
which can be passed as the last argument to both <code class="docutils literal notranslate"><span class="pre">align_string_sequences</span></code>
and <code class="docutils literal notranslate"><span class="pre">align_sequence_to_polymer</span></code> functions.
The default scoring is +1 for match, -1 for mismatch, -1 for gap opening,
and -1 for each residue in the gap.
If we would like to calculate the
<a class="reference external" href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a>,
we would use the following scoring:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scoring</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">AlignmentScoring</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scoring</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scoring</span><span class="o">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scoring</span><span class="o">.</span><span class="n">gapo</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scoring</span><span class="o">.</span><span class="n">gape</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">align_string_sequences</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;kitten&#39;</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;sitting&#39;</span><span class="p">),</span> <span class="p">[],</span> <span class="n">scoring</span><span class="p">)</span> 
<span class="go">&lt;gemmi.AlignmentResult object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">score</span>
<span class="go">-3</span>
</pre></div>
</div>
<p>So the distance is 3, as expected.</p>
<p>In addition to the scoring parameters above, we can define a substitution
matrix. Gemmi includes ready-to-use BLOSUM62 matrix with the gap cost 10/1,
like in <a class="reference external" href="https://www.ncbi.nlm.nih.gov/blast/html/sub_matrix.html">BLAST</a>.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">blosum62</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">prepare_blosum62_scoring</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blosum62</span><span class="o">.</span><span class="n">gapo</span><span class="p">,</span> <span class="n">blosum62</span><span class="o">.</span><span class="n">gape</span>
<span class="go">(-10, -1)</span>
</pre></div>
</div>
<p>Now we can test it on one of examples from the
<a class="reference external" href="http://biopython.org/DIST/docs/tutorial/Tutorial.html">BioPython tutorial</a>.
First, we try global alignment:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">align_string_sequences</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">gemmi</span><span class="o">.</span><span class="n">expand_protein_one_letter_string</span><span class="p">(</span><span class="s1">&#39;LSPADKTNVKAA&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">gemmi</span><span class="o">.</span><span class="n">expand_protein_one_letter_string</span><span class="p">(</span><span class="s1">&#39;PEEKSAV&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">[],</span> <span class="n">blosum62</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="s1">&#39;LSPADKTNVKAA&#39;</span><span class="p">,</span> <span class="s1">&#39;PEEKSAV&#39;</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="go">LSPADKTNVKAA</span>
<span class="go">  |..|.   |.</span>
<span class="go">--PEEKS---AV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">score</span>
<span class="go">-7</span>
</pre></div>
</div>
<p>We have only global aligment available, but we can use free-gaps to
approximate a semi-global alignment (infix method) where gaps at the start
and at the end of the second sequence are not penalized.
Approximate – because only gap openings are not penalized,
residues in the gap still decrease the score:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">align_string_sequences</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">gemmi</span><span class="o">.</span><span class="n">expand_protein_one_letter_string</span><span class="p">(</span><span class="s1">&#39;LSPADKTNVKAA&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">gemmi</span><span class="o">.</span><span class="n">expand_protein_one_letter_string</span><span class="p">(</span><span class="s1">&#39;PEEKSAV&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="c1"># free gaps at 0 (start) and 7 (end):   01234567</span>
<span class="gp">... </span>        <span class="p">[</span><span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)],</span>
<span class="gp">... </span>        <span class="n">blosum62</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="s1">&#39;LSPADKTNVKAA&#39;</span><span class="p">,</span> <span class="s1">&#39;PEEKSAV&#39;</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  
<span class="go">LSPADKTNVKAA</span>
<span class="go">  |..|..|</span>
<span class="go">--PEEKSAV---</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">score</span>
<span class="go">11</span>
</pre></div>
</div>
<p>The real infix method (or local alignment) would yield the score 16 (11+5),
because we have 5 missing residues at the ends.</p>
<p>See also the <a class="reference internal" href="utils.html#gemmi-align"><span class="std std-ref">gemmi-align</span></a> program.</p>
</div>
</div>
<div class="section" id="model">
<h2>Model<a class="headerlink" href="#model" title="Permalink to this headline">¶</a></h2>
<p>Model contains chains (class <code class="docutils literal notranslate"><span class="pre">Chain</span></code>) that
can be accessed by index or by name:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// to access or delete a chain by index use directly the chains vector:</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Chain</span><span class="o">&gt;</span> <span class="n">Model</span><span class="o">::</span><span class="n">chains</span>
<span class="c1">// to access or delete a chain by name use functions:</span>
<span class="n">Chain</span><span class="o">*</span> <span class="n">Model</span><span class="o">::</span><span class="n">find_chain</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">chain_name</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">Model</span><span class="o">::</span><span class="n">remove_chain</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">chain_name</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1orc.pdb&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span>
<span class="go">&lt;gemmi.Model 1 with 1 chain(s)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&lt;gemmi.Chain A with 121 res&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="go">&lt;gemmi.Chain A with 121 res&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>  <span class="c1"># deletes chain A</span>
</pre></div>
</div>
<p>As it was shown in the <a class="reference internal" href="#met-mse-example"><span class="std std-ref">MET to MSE example</span></a>,
you can iterate over chains in the model.
You can also use function <code class="docutils literal notranslate"><span class="pre">all()</span></code> to iterate over all atoms in the model,
getting objects of the <a class="reference internal" href="#cra"><span class="std std-ref">CRA</span></a> class which holds three pointers –
chain, residue and atom. The function mutating MET to MSE could be
alternatively implemented as:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">met_to_mse2</span><span class="p">(</span><span class="n">st</span><span class="p">:</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Structure</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cra</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">cra</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;MET&#39;</span> <span class="ow">and</span> <span class="n">cra</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;SD&#39;</span><span class="p">:</span>
                <span class="n">cra</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;MSE&#39;</span>
                <span class="n">cra</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;SE&#39;</span>
                <span class="n">cra</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;Se&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To add a chain to the model, in C++ use directly methods of <code class="docutils literal notranslate"><span class="pre">Model::chains</span></code>
and in Python use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Model</span><span class="o">.</span><span class="n">add_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">pos</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>for example,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">add_chain</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">Chain</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">))</span>  <span class="c1"># add a new (empty) chain</span>
<span class="n">model</span><span class="o">.</span><span class="n">add_chain</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>          <span class="c1"># add a copy of chain #0</span>
</pre></div>
</div>
<p>Each <code class="docutils literal notranslate"><span class="pre">Model</span></code> in a Structure must have a unique name (<code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">name</span></code>).
Normally, models are numbered and the name is a number.
But according to the mmCIF spec the name does not need to be a number,
so just in case we store it as a string.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;1&#39;</span>
</pre></div>
</div>
<hr class="docutils" />
<p>As was discussed before, the PDBx/mmCIF format has also
a set of parallel identifiers. In particular, it has
<code class="docutils literal notranslate"><span class="pre">label_asym_id</span></code> in parallel to <code class="docutils literal notranslate"><span class="pre">auth_asym_id</span></code>.
In Gemmi the residues with the same <code class="docutils literal notranslate"><span class="pre">label_asym_id</span></code> are called
<a class="reference internal" href="#subchain"><span class="std std-ref">subchain</span></a>.
Subchain is represented by class <code class="docutils literal notranslate"><span class="pre">ResidueSpan</span></code>.
If you want to access a subchain with the specified <code class="docutils literal notranslate"><span class="pre">label_asym_id</span></code>, use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Model</span><span class="o">::</span><span class="n">get_subchain</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">sub_name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResidueSpan</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1pfe.cif.gz&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">get_subchain</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="go">&lt;gemmi.ResidueSpan of 8: [1(DG) 2(DC) 3(DG) ... 8(DC)]&gt;</span>
</pre></div>
</div>
<p>To get the list of all subchains in the model, use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Model</span><span class="o">::</span><span class="n">subchains</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ResidueSpan</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">subchain</span><span class="o">.</span><span class="n">subchain_id</span><span class="p">()</span> <span class="k">for</span> <span class="n">subchain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">subchains</span><span class="p">()]</span>
<span class="go">[&#39;A&#39;, &#39;C&#39;, &#39;F&#39;, &#39;B&#39;, &#39;D&#39;, &#39;E&#39;, &#39;G&#39;]</span>
</pre></div>
</div>
<p>The subchains got re-ordered when the chain parts were merged.
Alternatively, we could do:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1pfe.cif.gz&#39;</span><span class="p">,</span> <span class="n">merge_chain_parts</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">subchain</span><span class="o">.</span><span class="n">subchain_id</span><span class="p">()</span> <span class="k">for</span> <span class="n">subchain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">subchains</span><span class="p">()]</span>
<span class="go">[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ResidueSpan</span></code> is described in the next section.</p>
<hr class="docutils" />
<p>In Python, <code class="docutils literal notranslate"><span class="pre">Model</span></code> has also methods for often needed calculations:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">count_atom_sites</span><span class="p">()</span>
<span class="go">342</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">count_occupancies</span><span class="p">()</span>
<span class="go">302.9999997317791</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">calculate_mass</span><span class="p">()</span>
<span class="go">4395.826034891504</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">calculate_center_of_mass</span><span class="p">()</span>
<span class="go">&lt;gemmi.Position(-5.7572, 16.4099, 2.88299)&gt;</span>
</pre></div>
</div>
<p>In C++, the same functionality is provided by templated functions
from <code class="docutils literal notranslate"><span class="pre">gemmi/calculate.hpp</span></code>. These functions (in C++) can be applied not only
to <code class="docutils literal notranslate"><span class="pre">Model</span></code>, but also to <code class="docutils literal notranslate"><span class="pre">Structure</span></code>, <code class="docutils literal notranslate"><span class="pre">Chain</span></code> and <code class="docutils literal notranslate"><span class="pre">Residue</span></code>.</p>
</div>
<div class="section" id="chain">
<h2>Chain<a class="headerlink" href="#chain" title="Permalink to this headline">¶</a></h2>
<p>Chain corresponds to the chain in the PDB format and
to <code class="docutils literal notranslate"><span class="pre">_atom_site.auth_asym_id</span></code> in the mmCIF format.
It has a name and a list of residues (class <code class="docutils literal notranslate"><span class="pre">Residue</span></code>).</p>
<p>To get the name or access a residue by index,
in C++ you may access these properties directly:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Residue</span><span class="o">&gt;</span> <span class="n">residues</span><span class="p">;</span>
</pre></div>
</div>
<p>In Python, we also have the <code class="docutils literal notranslate"><span class="pre">name</span></code> property:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/1pfe.cif.gz&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;A&#39;</span>
</pre></div>
</div>
<p>but the residues are accessed by iterating or indexing directly
the chain object:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="c1"># first residue</span>
<span class="go">&lt;gemmi.Residue 1(DG) with 23 atoms&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># last residue</span>
<span class="go">&lt;gemmi.Residue 2070(HOH) with 1 atoms&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">chain_a</span><span class="p">)</span>
<span class="go">79</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">is_water</span><span class="p">()</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">chain_a</span><span class="p">)</span>
<span class="go">70</span>
</pre></div>
</div>
<p>To add a residue to the chain, in C++ use directly methods
of <code class="docutils literal notranslate"><span class="pre">Chain::residues</span></code> and in Python use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Chain</span><span class="o">.</span><span class="n">add_residue</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">pos</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>for example,</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># add a copy of the first residue at the end</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="o">.</span><span class="n">add_residue</span><span class="p">(</span><span class="n">chain_a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;gemmi.Residue 1(DG) with 23 atoms&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and then delete it</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">chain_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>In the literature, residues are referred to by sequence ID (number and,
optionally, insertion code) and residue name. To get residues with
with the specified sequence ID use indexing with a string as an argument:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span>
<span class="go">&lt;gemmi.ResidueGroup [1(DG)]&gt;</span>
</pre></div>
</div>
<p>The returned object is a ResidueGroup with a single residue,
unless we have a point mutation.
The ResidueGroup is documented later on. For now let’s only show
how to extract the residue we want:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">][</span><span class="s1">&#39;DG&#39;</span><span class="p">]</span>   <span class="c1"># gets residue DG</span>
<span class="go">&lt;gemmi.Residue 1(DG) with 23 atoms&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>      <span class="c1"># gets first residue in the group</span>
<span class="go">&lt;gemmi.Residue 1(DG) with 23 atoms&gt;</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Often, we need to refer to a part of the chain.
A span of consecutive residues can be represented by <code class="docutils literal notranslate"><span class="pre">ResidueSpan</span></code>.
For example, if we want to process separately the polymer, ligand
and water parts of the chain, we can use the following functions
that return <code class="docutils literal notranslate"><span class="pre">ResidueSpan</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ResidueSpan</span> <span class="n">Chain</span><span class="o">::</span><span class="n">get_polymer</span><span class="p">()</span>
<span class="n">ResidueSpan</span> <span class="n">Chain</span><span class="o">::</span><span class="n">get_ligands</span><span class="p">()</span>
<span class="n">ResidueSpan</span> <span class="n">Chain</span><span class="o">::</span><span class="n">get_waters</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="o">.</span><span class="n">get_polymer</span><span class="p">()</span>
<span class="go">&lt;gemmi.ResidueSpan of 8: [1(DG) 2(DC) 3(DG) ... 8(DC)]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="o">.</span><span class="n">get_ligands</span><span class="p">()</span>
<span class="go">&lt;gemmi.ResidueSpan of 1: [20(CL)]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="o">.</span><span class="n">get_waters</span><span class="p">()</span>
<span class="go">&lt;gemmi.ResidueSpan of 70: [2001(HOH) 2002(HOH) 2003(HOH) ... 2070(HOH)]&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is possible because, conventionally, polymer is at the beginning
of the chain, waters are at the end, and ligands are in the middle.
It won’t work if for some reasons the residues of different categories
are intermixed.</p>
</div>
<p>We also have a function that returns the whole chain as a residue span:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ResidueSpan</span> <span class="n">Chain</span><span class="o">::</span><span class="n">whole</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="o">.</span><span class="n">whole</span><span class="p">()</span>
<span class="go">&lt;gemmi.ResidueSpan of 79: [1(DG) 2(DC) 3(DG) ... 2070(HOH)]&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Chain</span></code> has also functions <code class="docutils literal notranslate"><span class="pre">get_subchain()</span></code> and <code class="docutils literal notranslate"><span class="pre">subchains()</span></code>
that do the same as the functions of <code class="docutils literal notranslate"><span class="pre">Model</span></code> with the same names:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">subchain</span><span class="o">.</span><span class="n">subchain_id</span><span class="p">()</span> <span class="k">for</span> <span class="n">subchain</span> <span class="ow">in</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">subchains</span><span class="p">()]</span>
<span class="go">[&#39;A&#39;, &#39;C&#39;, &#39;F&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">subchain</span><span class="o">.</span><span class="n">subchain_id</span><span class="p">()</span> <span class="k">for</span> <span class="n">subchain</span> <span class="ow">in</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">subchains</span><span class="p">()]</span>
<span class="go">[&#39;B&#39;, &#39;D&#39;, &#39;E&#39;, &#39;G&#39;]</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Now let us consider microheterogeneities (point mutations).
They are less frequent than alternative conformations of atoms
in a residue, but we still need to handle them.
So we have two approaches, as mentioned before in the section
about <a class="reference internal" href="#altconf"><span class="std std-ref">alternative conformations</span></a>.</p>
<p>For quick and approximate analysis of the structure, one may get by
with ignoring all but the first (main) conformer.
Both <code class="docutils literal notranslate"><span class="pre">Chain</span></code> and <code class="docutils literal notranslate"><span class="pre">ResidueSpan</span></code> have function <code class="docutils literal notranslate"><span class="pre">first_conformer()</span></code>
which returns iterator over residues of the main conformer.</p>
<div class="highlight-pycon3 notranslate" id="polymer-b-sequence"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">polymer_b</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get_polymer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iteration goes through all residues and atom sites</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">polymer_b</span><span class="p">]</span>
<span class="go">[&#39;DSN&#39;, &#39;ALA&#39;, &#39;N2C&#39;, &#39;NCY&#39;, &#39;MVA&#39;, &#39;DSN&#39;, &#39;ALA&#39;, &#39;NCY&#39;, &#39;N2C&#39;, &#39;MVA&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The two pairs N2C/NCY above are alternative conformations.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Sometimes we want to ignore alternative conformations:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">polymer_b</span><span class="o">.</span><span class="n">first_conformer</span><span class="p">()]</span>
<span class="go">[&#39;DSN&#39;, &#39;ALA&#39;, &#39;N2C&#39;, &#39;MVA&#39;, &#39;DSN&#39;, &#39;ALA&#39;, &#39;NCY&#39;, &#39;MVA&#39;]</span>
</pre></div>
</div>
<p>A more complex approach is to group together the alternatives.
Such a group is represented by <code class="docutils literal notranslate"><span class="pre">ResidueGroup</span></code>, which is derived from
<code class="docutils literal notranslate"><span class="pre">ResidueSpan</span></code>.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">polymer_b</span><span class="o">.</span><span class="n">residue_groups</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">group</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;  &#39;</span><span class="p">)</span>  
<span class="go">DSN  ALA  N2C,NCY  MVA  DSN  ALA  NCY,N2C  MVA</span>
</pre></div>
</div>
<hr class="docutils" />
<p>In Python, Chain has a few specialized, but commonly used functions.
Three that are present also in the Model class:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="o">.</span><span class="n">count_atom_sites</span><span class="p">()</span>
<span class="go">242</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="o">.</span><span class="n">count_occupancies</span><span class="p">()</span>
<span class="go">216.9999997317791</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="o">.</span><span class="n">calculate_mass</span><span class="p">()</span>
<span class="go">3211.093834891507</span>
</pre></div>
</div>
<p>and a function that changes a polypeptide chain into polyalanine:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span><span class="o">.</span><span class="n">trim_to_alanine</span><span class="p">()</span>
</pre></div>
</div>
<p>In C++ <code class="docutils literal notranslate"><span class="pre">trim_to_alanine()</span></code> is defined in <code class="docutils literal notranslate"><span class="pre">gemmi/polyheur.hpp</span></code>.</p>
</div>
<div class="section" id="residuespan-residuegroup">
<span id="residuespan"></span><h2>ResidueSpan, ResidueGroup<a class="headerlink" href="#residuespan-residuegroup" title="Permalink to this headline">¶</a></h2>
<p>ResidueSpan and ResidueGroup are lightweight structures that point
to a consecutive span of residues in a chain.
But as was was shown in the previous section, they are used for different
things.</p>
<p>Both allow addressing residue by (0-based) index:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># in the following examples we use polymer_b from the previous section</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polymer_b</span>
<span class="go">&lt;gemmi.ResidueSpan of 10: [1(DSN) 2(ALA) 3(N2C) ... 8(MVA)]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polymer_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># gets residue by index</span>
<span class="go">&lt;gemmi.Residue 2(ALA) with 5 atoms&gt;</span>
</pre></div>
</div>
<p>You can iterate over residues, although for ResidueSpan it may be better
to iterate only over one conformer:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># iterating over all residues</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">polymer_b</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>  
<span class="go">DSN ALA N2C NCY MVA DSN ALA NCY N2C MVA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iterating over primary (first) conformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">polymer_b</span><span class="o">.</span><span class="n">first_conformer</span><span class="p">():</span> <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>  
<span class="go">DSN ALA N2C MVA DSN ALA NCY MVA</span>
</pre></div>
</div>
<p>Related to this, the length can be calculating in two ways:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">polymer_b</span><span class="p">)</span>      <span class="c1"># number of residues</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polymer_b</span><span class="o">.</span><span class="n">length</span><span class="p">()</span>  <span class="c1"># length of the chain (which has 2 point mutations)</span>
<span class="go">8</span>
</pre></div>
</div>
<p>The functions for adding and removing residues are the same as in Chain:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># add a new (empty) residue at the beginning</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polymer_b</span><span class="o">.</span><span class="n">add_residue</span><span class="p">(</span><span class="n">gemmi</span><span class="o">.</span><span class="n">Residue</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">&lt;gemmi.Residue ?() with 0 atoms&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and delete it</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">polymer_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>If ResidueSpan represents a subchain we can get its ID (<code class="docutils literal notranslate"><span class="pre">label_asym_id</span></code>):</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">polymer_b</span><span class="o">.</span><span class="n">subchain_id</span><span class="p">()</span>
<span class="go">&#39;B&#39;</span>
</pre></div>
</div>
<p>If it’s a polymer, we can ask for polymer type and sequence:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">polymer_b</span><span class="o">.</span><span class="n">check_polymer_type</span><span class="p">()</span>
<span class="go">PolymerType.PeptideL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polymer_b</span><span class="o">.</span><span class="n">make_one_letter_sequence</span><span class="p">()</span>
<span class="go">&#39;sAXvsAXv&#39;</span>
</pre></div>
</div>
<p>(In C++ these two functions are available in <code class="docutils literal notranslate"><span class="pre">gemmi/polyheur.hpp</span></code>.)</p>
<p>In addition to the numeric indexing,
<code class="docutils literal notranslate"><span class="pre">ResidueSpan.__getitem__</span></code> (like <code class="docutils literal notranslate"><span class="pre">Chain.__getitem__</span></code>) can take
sequence ID as a string, returning ResidueGroup.
In ResidueGroup we can uniquely address a residue by name, therefore
<code class="docutils literal notranslate"><span class="pre">ResidueGroup.__getitem__</span></code> (and <code class="docutils literal notranslate"><span class="pre">__delitem__</span></code>) takes residue name.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">polymer_b</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">]</span>  <span class="c1"># ResidueSpan[sequence ID] -&gt; ResidueGroup</span>
<span class="go">&lt;gemmi.ResidueGroup [2(ALA)]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">[</span><span class="s1">&#39;ALA&#39;</span><span class="p">]</span>        <span class="c1"># ResidueGroup[residue name] -&gt; Residue</span>
<span class="go">&lt;gemmi.Residue 2(ALA) with 5 atoms&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="residue">
<h2>Residue<a class="headerlink" href="#residue" title="Permalink to this headline">¶</a></h2>
<p>Residue contains atoms (class <code class="docutils literal notranslate"><span class="pre">Atom</span></code>).</p>
<p>From C++ you may access directly the list of atoms:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Atom</span><span class="o">&gt;</span> <span class="n">Residue</span><span class="o">::</span><span class="n">atoms</span>
</pre></div>
</div>
<p>Or you may use helper functions that take:
atom name,
alternative location (<code class="docutils literal notranslate"><span class="pre">'*'</span></code> = take the first matching atom regardless
of altloc, <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> = no altloc)
and, optionally, also the expected element if you want to verify it:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Atom</span><span class="o">*</span> <span class="n">Residue</span><span class="o">::</span><span class="n">find_atom</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">atom_name</span><span class="p">,</span> <span class="kt">char</span> <span class="n">altloc</span><span class="p">,</span> <span class="n">El</span> <span class="n">el</span><span class="o">=</span><span class="n">El</span><span class="o">::</span><span class="n">X</span><span class="p">)</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Atom</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">Residue</span><span class="o">::</span><span class="n">find_atom_iter</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">atom_name</span><span class="p">,</span> <span class="kt">char</span> <span class="n">altloc</span><span class="p">,</span> <span class="n">El</span> <span class="n">el</span><span class="o">=</span><span class="n">El</span><span class="o">::</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>If atom is not found, the first function return <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>,
the second one throws exception.</p>
<p>To get all atoms with given name as <code class="docutils literal notranslate"><span class="pre">AtomGroup</span></code> (most often it will be
just a single atom) use <code class="docutils literal notranslate"><span class="pre">Residue::get(const</span> <span class="pre">std::string&amp;</span> <span class="pre">name)</span></code>.</p>
<p>In Python it is similar (but <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> is used instead of <code class="docutils literal notranslate"><span class="pre">get()</span></code>):</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">polymer_b</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">][</span><span class="s1">&#39;ALA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span>
<span class="go">&lt;gemmi.Residue 2(ALA) with 5 atoms&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&lt;gemmi.Atom N at (-9.9, 10.9, 13.5)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&lt;gemmi.Atom CB at (-10.6, 9.7, 11.5)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">find_atom</span><span class="p">(</span><span class="s1">&#39;CA&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
<span class="go">&lt;gemmi.Atom CA at (-9.5, 10.0, 12.5)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="p">[</span><span class="s1">&#39;CA&#39;</span><span class="p">]</span>
<span class="go">&lt;gemmi.AtomGroup CA, sites: 1&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Residue also has ``__contains__`` and ``__iter__``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;CB&#39;</span> <span class="ow">in</span> <span class="n">residue</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">)</span>
<span class="go">&#39;N CA C O CB&#39;</span>
</pre></div>
</div>
<p>Atoms can be added, modified and removed:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_atom</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Atom</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_atom</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;HA&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">new_atom</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># added at (0-based) position 2</span>
<span class="go">&lt;gemmi.Atom HA at (0.0, 0.0, 0.0)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">residue</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Residue contains also a number of properties:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> – residue name, such as ALA,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seqid</span></code> – sequence ID, class SeqId with two properties:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">num</span></code> – sequence number,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">icode</span></code> – insertion code (a single character, <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">'</span></code> = none),</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">segment</span></code> – segment from the PDB format v2,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">subchain</span></code> – label_asym_id from mmCIF file, or ID generated by
<code class="docutils literal notranslate"><span class="pre">Structure.assign_subchains()</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">label_seq</span></code> – numeric value from the label_seq_id field.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">entity_type</span></code> – one of EntityType.Unknown, Polymer, NonPolymer, Water,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">het_flag</span></code> – a single character based on the PDB record or
on the _atom_site.group_PDB field:
<code class="docutils literal notranslate"><span class="pre">A</span></code>=ATOM, <code class="docutils literal notranslate"><span class="pre">H</span></code>=HETATM, <code class="docutils literal notranslate"><span class="pre">\0</span></code>=unspecified,</p></li>
</ul>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">seqid</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">residue</span><span class="o">.</span><span class="n">seqid</span><span class="o">.</span><span class="n">icode</span>
<span class="go">(2, &#39; &#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">subchain</span>
<span class="go">&#39;B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">label_seq</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">entity_type</span>
<span class="go">EntityType.Polymer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">het_flag</span>
<span class="go">&#39;A&#39;</span>
</pre></div>
</div>
<p>To check if a residue is water (normal or heavy) you may use a helper
function:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">is_water</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Classes Chain and ResidueSpan have function <code class="docutils literal notranslate"><span class="pre">first_conformer()</span></code>
for iterating over residues of one conformer.
Similarly, <code class="docutils literal notranslate"><span class="pre">Residue::first_conformer()</span></code> iterates over atoms of
a single conformer:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span> 
<span class="go">O5&#39; C5&#39; C4&#39; C4&#39; O4&#39; C3&#39; C3&#39; O3&#39; O3&#39; C2&#39; C2&#39; C1&#39; N9 C8 N7 C5 C6 O6 N1 C2 N2 N3 C4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">first_conformer</span><span class="p">():</span> <span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span> 
<span class="go">O5&#39; C5&#39; C4&#39; O4&#39; C3&#39; O3&#39; C2&#39; C1&#39; N9 C8 N7 C5 C6 O6 N1 C2 N2 N3 C4</span>
</pre></div>
</div>
</div>
<div class="section" id="atomgroup">
<h2>AtomGroup<a class="headerlink" href="#atomgroup" title="Permalink to this headline">¶</a></h2>
<p>AtomGroup represents alternative locations of the same atom.
It is implemented as a lightweight object that points
to a consecutive atoms (atom sites) inside the same Residue.
It has minimal functionality:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="p">[</span><span class="s2">&quot;O5&#39;&quot;</span><span class="p">]</span>
<span class="go">&lt;gemmi.AtomGroup O5&#39;, sites: 1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&quot;O5&#39;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">residue</span><span class="p">[</span><span class="s2">&quot;O5&#39;&quot;</span><span class="p">])</span>
<span class="go">1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="p">[</span><span class="s2">&quot;O3&#39;&quot;</span><span class="p">]</span>
<span class="go">&lt;gemmi.AtomGroup O3&#39;, sites: 2&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="p">[</span><span class="s2">&quot;O3&#39;&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>    <span class="c1"># get atom site by index</span>
<span class="go">&lt;gemmi.Atom O3&#39;.A at (-8.3, 20.3, 17.9)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="p">[</span><span class="s2">&quot;O3&#39;&quot;</span><span class="p">][</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>  <span class="c1"># get atom site by altloc</span>
<span class="go">&lt;gemmi.Atom O3&#39;.A at (-8.3, 20.3, 17.9)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">[</span><span class="s2">&quot;O3&#39;&quot;</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">altloc</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>  
<span class="go">A B</span>
</pre></div>
</div>
</div>
<div class="section" id="atom">
<h2>Atom<a class="headerlink" href="#atom" title="Permalink to this headline">¶</a></h2>
<p>Atom (more accurately: atom site) has the following properties:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> – atom name, such as <code class="docutils literal notranslate"><span class="pre">CA</span></code> or <code class="docutils literal notranslate"><span class="pre">CB</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">altloc</span></code> – alternative location indicator (one character),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">charge</span></code> – integer number (partial charges are not supported),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – <a class="reference internal" href="#elements"><span class="std std-ref">element</span></a> from a periodic table,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code> – coordinates in Angstroms (instance of <code class="docutils literal notranslate"><span class="pre">Position</span></code>),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">occ</span></code> – occupancy,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b_iso</span></code> – isotropic temperature factor or, more accurately,
atomic displacement parameter (ADP),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">aniso</span></code> – anisotropic atomic displacement parameters (U not B).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">serial</span></code> – atom serial number (integer).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">flag</span></code> – custom flag, a single character that can be used for anything
by the user.</p></li>
</ul>
<p>These properties can be read and written from both C++ and Python,
as was shown in <a class="reference internal" href="#met-mse-example"><span class="std std-ref">the example</span></a> where sulfur
was mutated to selenium.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">polymer_b</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">][</span><span class="s1">&#39;ALA&#39;</span><span class="p">][</span><span class="s1">&#39;CA&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;CA&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">element</span>
<span class="go">&lt;gemmi.Element: C&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">pos</span>
<span class="go">&lt;gemmi.Position(-9.498, 10.028, 12.461)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">occ</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">b_iso</span>
<span class="go">9.4399995803833</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">serial</span>
<span class="go">179</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">flag</span>
<span class="go">&#39;\x00&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">altloc</span></code> is stored as a single character. Majority of atoms has
a single conformations and the altloc character set to NUL (<code class="docutils literal notranslate"><span class="pre">'\0'</span></code>).
If you want to check if an atom has non-NUL altloc, you may also use
method <code class="docutils literal notranslate"><span class="pre">has_altloc()</span></code>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">altloc</span>
<span class="go">&#39;\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">has_altloc</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">element</span></code> can be compared (<code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>) with other instances
of gemmi.Element. For checking if it is a hydrogen we have a dedicated
function <code class="docutils literal notranslate"><span class="pre">is_hydrogen()</span></code> which returns true for both H and D:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">element</span> <span class="o">==</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">is_hydrogen</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p><strong>B-factors</strong> – atomic displacement parameters.</p>
<p>The PDB format stores isotropic ADP as <em>B</em> and
anisotropic as <em>U</em> (<em>B</em> = 8<em>π</em><sup>2</sup><em>U</em>).
So is Gemmi:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">b_iso</span>
<span class="go">9.4399995803833</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>  <span class="c1"># has non-zero anisotropic ADP</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%g</span><span class="s1"> </span><span class="si">%g</span><span class="s1"> </span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u11</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u22</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u33</span><span class="p">)</span>
<span class="go">&#39;0.1386 0.1295 0.0907&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%g</span><span class="s1"> </span><span class="si">%g</span><span class="s1"> </span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u12</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u23</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">u23</span><span class="p">)</span>
<span class="go">&#39;-0.0026 0.0068 0.0068&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U_eq</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">aniso</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%g</span><span class="s1"> ~= </span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">b_iso</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">U_eq</span><span class="p">)</span>
<span class="go">&#39;9.44 ~= 9.44324&#39;</span>
</pre></div>
</div>
<p>Anisotropic models also contain <em>B</em><sub>iso</sub>, which should be
a full isotropic B-factor. But, as discussed in the
<a class="reference external" href="http://dx.doi.org/10.1093/protein/gzu044">BDB paper</a>,
some PDB entries contain “residual” B-factors instead.
Moreover, “full isotropic ADP” can mean different things.
Usually, <em>B</em><sub>eq</sub> is used (<em>B</em><sub>eq</sub> ~ tr(<em>U</em><sub>ij</sub>)).
But because <em>B</em><sub>eq</sub> tends to give values larger than the B-factors
that would be obtained in isotropic refinement,
<a class="reference external" href="https://doi.org/10.1107/S0108767311034350">Ethan Merrit proposed</a>
a metric named <em>B</em><sub>est</sub>, more similar to the would-be isotropic <em>B</em>s.
Gemmi can calculate both:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">b_eq</span><span class="p">()</span>                    <span class="c1"># B_eq</span>
<span class="go">9.443238117199861</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemmi</span><span class="o">.</span><span class="n">calculate_b_est</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>    <span class="c1"># B_est</span>
<span class="go">9.15448356208817</span>
</pre></div>
</div>
</div>
<div class="section" id="atomaddress-and-cra">
<span id="atom-address"></span><h2>AtomAddress and CRA<a class="headerlink" href="#atomaddress-and-cra" title="Permalink to this headline">¶</a></h2>
<p>Atoms are often referred to by specifying their chain, residue, atom name
and, optionally, altloc. In gemmi, a structure to store such a specification
is called AtomAddress.
For instance, the following line from a PDB file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LINK         C   22Q A   1                 N   ALA A   2     1555   1555  1.34
</pre></div>
</div>
<p>corresponds to Connection that contains two addresses:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="s1">&#39;../tests/4oz7.pdb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&lt;gemmi.Connection covale1  A/22Q 1/C - A/ALA 2/N&gt;</span>
</pre></div>
</div>
<p>Let us check the properties of the second address:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span> <span class="o">=</span> <span class="n">_</span><span class="o">.</span><span class="n">partner2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span>
<span class="go">&lt;gemmi.AtomAddress A/ALA 2/N&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span><span class="o">.</span><span class="n">chain_name</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span><span class="o">.</span><span class="n">res_id</span>
<span class="go">&lt;gemmi.ResidueId 2(ALA)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span><span class="o">.</span><span class="n">res_id</span><span class="o">.</span><span class="n">seqid</span>
<span class="go">&lt;gemmi.SeqId 2&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span><span class="o">.</span><span class="n">res_id</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;ALA&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span><span class="o">.</span><span class="n">atom_name</span>
<span class="go">&#39;N&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span><span class="o">.</span><span class="n">altloc</span>
<span class="go">&#39;\x00&#39;</span>
</pre></div>
</div>
<p id="cra">A valid AtomAddress points to a chain, residue and atom in a model.
Pointers to the Chain, Residue and Atom can be kept together in
another small structure, called CRA:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cra</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">find_cra</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cra</span>
<span class="go">&lt;gemmi.CRA A/ALA 2/N&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cra</span><span class="o">.</span><span class="n">chain</span>
<span class="go">&lt;gemmi.Chain A with 21 res&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cra</span><span class="o">.</span><span class="n">residue</span>
<span class="go">&lt;gemmi.Residue 2(ALA) with 5 atoms&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cra</span><span class="o">.</span><span class="n">atom</span>
<span class="go">&lt;gemmi.Atom N at (-24.5, -13.9, 14.8)&gt;</span>
</pre></div>
</div>
<p>Now, as an exercise, we will delete and re-create a disulfide bond:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># remove</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&lt;gemmi.Connection disulf1  A/CYS 4/SG - A/CYS 10/SG&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Connection</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span>
<span class="go">&lt;gemmi.Connection   / ?/ - / ?/&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;new_disulf&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">ConnectionType</span><span class="o">.</span><span class="n">Disulf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">asu</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">Asu</span><span class="o">.</span><span class="n">Same</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_a</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res4</span> <span class="o">=</span> <span class="n">chain_a</span><span class="p">[</span><span class="s1">&#39;4&#39;</span><span class="p">][</span><span class="s1">&#39;CYS&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res10</span> <span class="o">=</span> <span class="n">chain_a</span><span class="p">[</span><span class="s1">&#39;10&#39;</span><span class="p">][</span><span class="s1">&#39;CYS&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">partner1</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">AtomAddress</span><span class="p">(</span><span class="n">chain_a</span><span class="p">,</span> <span class="n">res4</span><span class="p">,</span> <span class="n">res4</span><span class="o">.</span><span class="n">sole_atom</span><span class="p">(</span><span class="s1">&#39;SG&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">partner2</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">AtomAddress</span><span class="p">(</span><span class="n">chain_a</span><span class="p">,</span> <span class="n">res10</span><span class="p">,</span> <span class="n">res10</span><span class="o">.</span><span class="n">sole_atom</span><span class="p">(</span><span class="s1">&#39;SG&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&lt;gemmi.Connection new_disulf  A/CYS 4/SG - A/CYS 10/SG&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="chain-longer-than-cell">
<span id="long-chain"></span><h3>Chain longer than cell<a class="headerlink" href="#chain-longer-than-cell" title="Permalink to this headline">¶</a></h3>
<p>Is it possible for a single chain to exceed the size of the unit cell
in one of the directions? How much longer can it be than the cell?</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># This script looks for chains that exceed the size of the unit cell (by &gt;20%)</span>
<span class="c1"># in one of the a, b, c directions.</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">gemmi</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">is_crystal</span><span class="p">():</span>
        <span class="n">st</span><span class="o">.</span><span class="n">add_entity_types</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">polymer</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_polymer</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">polymer</span><span class="p">:</span>
                <span class="n">low_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+inf&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span>
                <span class="n">high_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span>
                <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">polymer</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">:</span>
                        <span class="n">pos</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">fractionalize</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">low_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                <span class="n">low_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">high_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                <span class="n">high_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">high_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">low_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="mf">1.2</span><span class="p">:</span>  <span class="c1"># 120% of the unit cell size</span>
                        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">code</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;_entry.id&#39;</span><span class="p">]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">   chain:</span><span class="si">%s</span><span class="s1">   delta</span><span class="si">%c</span><span class="s1"> = </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span>
                              <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">chain</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">delta</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">counter</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">CoorFileWalk</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">run</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>When run on the PDB database (on a local copy of either pdb or mmCIF files)
this script prints too many lines to show here.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ./examples/long_geom.py <span class="nv">$PDB_DIR</span>/structures/divided/pdb/
<span class="go">105M   chain:A   deltaY = 1.225</span>
<span class="go">208L   chain:A   deltaZ = 1.203</span>
<span class="go">11BA   chain:A   deltaX = 1.227</span>
<span class="go">11BA   chain:B   deltaX = 1.202</span>
<span class="go">...</span>
<span class="go">3NWH   chain:A   deltaX = 3.893</span>
<span class="go">3NWH   chain:B   deltaX = 3.955</span>
<span class="go">3NWH   chain:C   deltaX = 4.093</span>
<span class="go">3NWH   chain:D   deltaX = 3.472</span>
<span class="go">...</span>
<span class="go">5XG2   chain:A   deltaX = 4.267</span>
<span class="go">5XG2   chain:A   deltaZ = 1.467</span>
<span class="go">...</span>
</pre></div>
</div>
<p>As we see, a single chain may be even longer than four unit cells in one
of the directions.  How such chains look like?</p>
<p>For example, here is 3NWH – a homo-4-mer in P2
(4 x 2 chains per unit cell) – colored by chain id:</p>
<a class="reference external image-reference" href="https://www.rcsb.org/3d-view/3NWH/"><img alt="_images/3nwh.png" class="align-center" src="_images/3nwh.png" style="width: 390.0px; height: 166.0px;" /></a>
<p>And here is 5XG2 – a monomer in P21 – with two copies of the
rainbow-colored chain:</p>
<a class="reference external image-reference" href="https://www.rcsb.org/3d-view/5XG2/"><img alt="_images/5xg2.png" class="align-center" src="_images/5xg2.png" style="width: 362.0px; height: 120.0px;" /></a>
</div>
<div class="section" id="ccd-subset">
<h3>CCD subset<a class="headerlink" href="#ccd-subset" title="Permalink to this headline">¶</a></h3>
<p>Since the whole Chemical Component Dictionary is large
we may want to extract a subset of it that covers only residues
in given structures.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make a list of residue names that we need.</span>
<span class="n">mon_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">coordinate_file</span> <span class="ow">in</span> <span class="n">COORDINATE_FILES</span><span class="p">:</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">read_structure</span><span class="p">(</span><span class="n">coordinate_file</span><span class="p">)</span>
    <span class="n">mon_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_all_residue_names</span><span class="p">())</span>

<span class="c1"># Copy blocks corresponding to these residues to a new file.</span>
<span class="n">sub</span> <span class="o">=</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">cif</span><span class="o">.</span><span class="n">Document</span><span class="p">()</span>
<span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">gemmi</span><span class="o">.</span><span class="n">cif</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">CCD_PATH</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">mon_names</span><span class="p">:</span>
        <span class="n">sub</span><span class="o">.</span><span class="n">add_copied_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
<span class="n">sub</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">)</span>
</pre></div>
</div>
<p>For complete and ready-to-use script see <code class="file docutils literal notranslate"><span class="pre">examples/sub_ccd.py</span></code>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="analysis.html" class="btn btn-neutral float-right" title="Structure analysis" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="symmetry.html" class="btn btn-neutral float-left" title="Symmetry" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2020 Global Phasing Ltd

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>